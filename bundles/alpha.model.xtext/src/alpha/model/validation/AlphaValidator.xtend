/*
 * generated by Xtext 2.13.0
 */
package alpha.model.validation

import alpha.model.AlphaNameUniquenessChecker
import alpha.model.AlphaRoot
import alpha.model.AlphaSystem
import alpha.model.JNIDomainCalculator
import alpha.model.issue.AlphaIssue
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.ValidationMessageAcceptor
import org.eclipse.emf.ecore.util.EcoreUtil;
import alpha.model.AlphaInternalStateConstructor
import org.eclipse.xtext.validation.CheckType

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AlphaValidator extends AbstractAlphaValidator {
	
	//helper to switch between error/warning 
	private def flagEditor(AlphaIssue.TYPE type, String message, EObject source, EStructuralFeature feature, int index) {
		if (type == AlphaIssue.TYPE.ERROR) {
			error(message, source, feature, index)
		}
		if (type == AlphaIssue.TYPE.WARNING) {
			warning(message, source, feature, index)
		}	
	}
	
	@Check(NORMAL)
	def checkRoot(AlphaRoot root) {
		val issues = AlphaInternalStateConstructor.compute(root);
		issues.filter[i|EcoreUtil.isAncestor(root, i.source)].forEach[i|flagEditor(i.type, i.message, i.source, i.feature, ValidationMessageAcceptor.INSIGNIFICANT_INDEX)]
	}
}
