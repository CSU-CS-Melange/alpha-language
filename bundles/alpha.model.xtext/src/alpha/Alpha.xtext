// automatically generated by Xtext
grammar alpha.model.Alpha with org.eclipse.xtext.common.Terminals

import "alpha.model"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

AlphaRoot:
	elements+=(AlphaConstant | ExternalFunction | Imports | AlphaPackage | AlphaSystem)*
;

AlphaConstant:
	'constant' name=ID '=' value=INT
;

ExternalFunction:
	'external' name=ID '(' cardinality=INT ')'
;

Imports:
	'import' importedNamespace=QualifiedNameWithWildcard
;

AlphaPackage:
	'package' name=QualifiedName '{'
		elements+=(AlphaConstant | ExternalFunction | AlphaPackage | AlphaSystem)*
	'}';

AlphaSystem:
	'affine' name=SystemName parameterDomainExpr=JNIParamDomain
		('define' (definedObjects+=PolyhedralObject)+)?
		('inputs' (inputs+=InputVariable)+)?
		('outputs' (outputs+=OutputVariable)+)?
		('locals' (locals+=LocalVariable)+)?
		('fuzzy' (fuzzyVariables+=FuzzyVariable)+)?
		('over' whileDomainExpr=CalculatorExpression 'while' '(' testExpression=AlphaExpression ')' )?
		('let' 
				(useEquations+=UseEquation)*
				(equations+=StandardEquation)*
		)?
	'.';
	
InputVariable:
	name=ID ':' (domainExpr=CalculatorExpression)? ';'?
;
OutputVariable:
	name=ID ':' (domainExpr=CalculatorExpression)? ';'?
;
LocalVariable:
	name=ID ':' (domainExpr=CalculatorExpression)? ';'?
;	

FuzzyVariable:
	name=ID ':' (domainExpr=CalculatorExpression)? ';'?
;

JNIDomain:
	islString=AISLSet
;
JNIDomainInArrayNotation:
	'{' ':' islString=AISLString '}'
;

JNIParamDomain returns JNIDomain:
	islString=AParamDomain
;
JNIRelation:
	islString=AISLRelation
;

JNIFunction:
	alphaString=AAlphaFunction
;

JNIFunctionInArrayNotation:
	'[' {JNIFunctionInArrayNotation} (arrayNotation+=AISLExpression (',' arrayNotation+=AISLExpression)*)? ']'
;

JNIFuzzyFunction:
	alphaString=AISLFuzzyRelation
;

JNIFuzzyFunctionInArrayNotation:
	'[[' {JNIFuzzyFunctionInArrayNotation} (arrayNotation+=AISLFuzzyExpression (',' arrayNotation+=AISLFuzzyExpression)*)? ']]'
;

QualifiedName:
  ID ('.' ID)*
;
QualifiedNameWithWildcard:
  QualifiedName '.*'?
;

SystemName:
	ID// ('-' ID)*
;

IndexName:
	ID
;

//IndexDimension:
//	name=IndexName
//;

AIndexList:
	(IndexName (',' IndexName)*)?;

//ISL syntax defs

AParamDomain:
	'[' AIndexList ']' '->' '{' ':' AISLString '}' 
;

AISLSet:
	'{' AISLBasicSet (';' AISLBasicSet)* '}'
;

AISLBasicSet:
	'[' AIndexList ']' ':' AISLString
;

AISLRelation:
	'{' AISLBasicRelation (';' AISLBasicRelation)* '}'
;

AISLString:
	(IndexName|INT|'+'|'-'|'*'|'/'|'%'|'and'|'or'|'['|']'|'('|')'|','|':'|'&'|'|'|WS|'>='|'>'|'='|'<'|'<=')*;
	
AISLExpression:
	(IndexName|INT|'='|'+'|'-'|'*'|'/'|'%'|WS)+;
	
AISLExpressionList:
	(AISLExpression (',' AISLExpression)*)?;

AAlphaFunction:
	'(' AIndexList '->' AISLExpressionList ')'
;

AISLBasicRelation:
	'[' AIndexList ']' '->' '[' AISLExpressionList ']' ':' AISLString
;


AISLFuzzyRelation:
	'{' AISLWrappedBasicRelation (';' AISLIndirection)* '}'
;

AISLWrappedBasicRelation:
	'[[' AIndexList ']' '->' '[' AISLExpressionList ']]'
;

AISLIndirection:
	'[' AIndexList ']' '->' IndexName '[' AISLExpressionList ']'
;

AISLFuzzyExpression:
	(IndexName|INT|'['|']'|'='|'+'|'-'|'*'|'/'|'%'|WS)+;	

//AIndexAffineExpression:	
//	 '-'? AIndexAffineExpressionTerminal (('+'|'-') AIndexAffineExpression)*;
//	
//AIndexAffineExpressionTerminal:
//	(INT | INT? IndexName);


StandardEquation :
	variable=[Variable] ('[' indexNames+=IndexName (',' indexNames+=IndexName)* ']')?  '=' expr=AlphaExpression ';';
	
UseEquation :
	('over' instantiationDomainExpr=CalculatorExpression ('with' ('[' subsystemDims+=IndexName (',' subsystemDims+=IndexName)* ']')?)? ':')? '(' (outputExprs += AlphaExpression (',' outputExprs += AlphaExpression)* )? ')'
	 '=' 
	system=[AlphaSystem|QualifiedName] callParamsExpr=JNIFunctionInArrayNotation
	'(' (inputExprs  += AlphaExpression (',' inputExprs  += AlphaExpression)* )? ')' 
	 ';';
	 	

/* Alpha Expressions */
AlphaExpression:
	IfExpression |
	RestrictExpression |
	AutoRestrictExpression |
	OrExpression
;

AlphaTerminalExpression returns AlphaExpression:
	'(' AlphaExpression ')' |
	CaseExpression |
	ConstantExpression |
	VariableExpression |
	DependenceExpression |
	FuzzyDependenceExpression |
	IndexExpression | 
	ReduceExpression |
	ArgReduceExpression |
	ConvolutionExpression |
	ExternalReduceExpression |
	ExternalArgReduceExpression |
	MultiArgExpression |
	ExternalMultiArgExpression |
	SelectExpression
;

IfExpression:
	'if' condExpr=AlphaExpression
	'then' thenExpr=AlphaExpression
	'else' elseExpr=AlphaExpression
;

RestrictExpression:
	domainExpr=(JNIDomain|JNIDomainInArrayNotation) ':' expr=AlphaExpression |
	'{' domainExpr=CalculatorExpression '}' ':' expr=AlphaExpression
;

AutoRestrictExpression:
	'auto' ':' expr=AlphaExpression
;

CaseExpression : 'case' name=ID? '{'
	(exprs+=AlphaExpression ';' )+
'}';

DependenceExpression:
	functionExpr=JNIFunction '@' expr=AlphaTerminalExpression |
	expr=VariableExpression functionExpr=JNIFunctionInArrayNotation;
	
FuzzyDependenceExpression:
	functionExpr=JNIFuzzyFunction '@' expr=AlphaTerminalExpression |
	expr=VariableExpression functionExpr=JNIFuzzyFunctionInArrayNotation;
		
IndexExpression:
	'val' functionExpr=JNIFunction |
	functionExpr=JNIFunctionInArrayNotation;

ReduceExpression:
	'reduce' '(' operator=AREDUCTION_OP ',' 
	projectionExpr=(JNIFunction|JNIFunctionInArrayNotation) ','
	body=AlphaExpression
	 ')'
;
ExternalReduceExpression:
	'reduce' '(' externalFunction=[ExternalFunction] ',' 
	projectionExpr=(JNIFunction|JNIFunctionInArrayNotation) ','
	body=AlphaExpression
	 ')'
;
ArgReduceExpression : 
	'argreduce' '(' operator=AREDUCTION_OP ',' 
	projectionExpr=(JNIFunction|JNIFunctionInArrayNotation) ','
	body=AlphaExpression
	 ')'
;
ExternalArgReduceExpression:
	'argreduce' '(' externalFunction=[ExternalFunction] ',' 
	projectionExpr=(JNIFunction|JNIFunctionInArrayNotation) ','
	body=AlphaExpression
	 ')'
;

ConvolutionExpression:
	'conv' '(' kernelDomainExpr=CalculatorExpression ',' 
	kernelExpression=AlphaExpression ','
	dataExpression=AlphaExpression
	 ')'
;

SelectExpression:
	'select' relationExpr=CalculatorExpression 'from' expr=AlphaTerminalExpression
;
	
OrExpression returns AlphaExpression:
	AndExpression ({BinaryExpression.left=current} operator=AOrOP right=AndExpression)*;

AndExpression returns AlphaExpression:
	RelationalExpression ({BinaryExpression.left=current} operator=AAndOP right=RelationalExpression)*;	

RelationalExpression returns AlphaExpression:
	AdditiveExpression ({BinaryExpression.left=current} operator=ARelationalOP right=AdditiveExpression)*;

AdditiveExpression returns AlphaExpression:
	MultiplicativeExpression ({BinaryExpression.left=current} operator=AAdditiveOP right=MultiplicativeExpression)*;

MultiplicativeExpression returns AlphaExpression:
	MinMaxExpression ({BinaryExpression.left=current} operator=AMultiplicativeOP right=MinMaxExpression)*;	

MinMaxExpression returns AlphaExpression:
	UnaryOrTerminalExpression ({BinaryExpression.left=current} operator=AMINMAX_OP right=UnaryOrTerminalExpression)*;

MultiArgExpression:
	operator=AREDUCTION_OP '(' exprs+=AlphaExpression (',' exprs+=AlphaExpression)* ')';
	
ExternalMultiArgExpression:
	externalFunction=[ExternalFunction] '(' exprs+=AlphaExpression (',' exprs+=AlphaExpression)* ')';	

UnaryOrTerminalExpression returns AlphaExpression:
	UnaryExpression | AlphaTerminalExpression; 
	
UnaryExpression:
	operator=AUnaryOP expr=AlphaTerminalExpression
;

VariableExpression:
	variable=[Variable]
;

ConstantExpression :
	BooleanExpression | RealExpression | IntegerExpression;
	
BooleanExpression :
	value=BOOLEAN;
	
IntegerExpression:
	value=INT;

RealExpression:
	value=FLOAT;	


AREDUCTION_OP returns REDUCTION_OP:
	"min" | "max" | "prod" | "sum" | "and" | "or" | "xor" | "+" | "*"
;

AOrOP returns BINARY_OP:
	"or" | "xor"
;

AAndOP returns BINARY_OP:
	"and"
;

ARelationalOP returns BINARY_OP:
	"=" | "!=" | ">=" | ">" | "<" | "<=";

AAdditiveOP returns BINARY_OP:
	"+" | "-";

AMultiplicativeOP returns BINARY_OP:
	"*" | "/";

AMINMAX_OP returns BINARY_OP:
	"min" | "max";
	
AUnaryOP returns UNARY_OP:
	"not" | "-"
;

/* Calculator Expressions */

PolyhedralObject:
	name=ID '=' expr=CalculatorExpression 
;
CalculatorExpression returns CalculatorExpression:
	UnaryOrTerminalCalculatorExpression ({BinaryCalculatorExpression.left=current} operator=ABinaryCalcOp right=UnaryOrTerminalCalculatorExpression)*
;

UnaryOrTerminalCalculatorExpression returns CalculatorExpression:
	UnaryCalculatorExpression | 
	CalculatorExpressionTerminal
;

CalculatorExpressionTerminal returns CalculatorExpression:
	JNIDomain |
	JNIRelation |
	JNIFunction |
	DefinedObject |
	RectangularDomain |
	VariableDomain | 
	'(' CalculatorExpression ')'
;

UnaryCalculatorExpression:
	operator=AUnaryCalcOp expr=CalculatorExpressionTerminal
;

VariableDomain:
	'{' variable=[Variable] '}'
;
RectangularDomain:
	'[' upperBounds+=IndexName (',' upperBounds+=IndexName)* ']' ('as' '[' indexNames+=IndexName (',' indexNames+=IndexName)* ']')? 
;
DefinedObject:
	object=[PolyhedralObject]
;

AUnaryCalcOp returns CALCULATOR_UNARY_OP:
	'domain'|'range'|'complement'|'affine-hull'|'poly-hull'|'reverse'
;

ABinaryCalcOp returns CALCULATOR_BINARY_OP:
	'cross'|'+'|'-'|'*'|'@'|'->-'|'->*' 
;




	
//ARITHMETIC_OP:
//	ARITHMETIC_REDUCTION_OP | ARITHMETIC_NONREDUCTION_OP
//;	
//
//LOGICAL_OP:
//	LOGICAL_REDUCTION_OP | LOGICAL_NONREDUCTION_OP
//;	
//	
//REDUCTION_OP:
//	ARITHMETIC_REDUCTION_OP | LOGICAL_REDUCTION_OP;
//	
//ARITHMETIC_REDUCTION_OP:
//	OP_MAX | OP_MIN | OP_MUL | OP_PLUS;
//	
//LOGICAL_REDUCTION_OP:
//	OP_AND | OP_OR | OP_XOR;
//	
//ARITHMETIC_NONREDUCTION_OP:
//	OP_MINUS | OP_DIV | OP_MOD;
//	
//LOGICAL_NONREDUCTION_OP:
//	OP_NAND;
//	
//RELATIONAL_OP :
//	OP_EQ | OP_GE | OP_GT | OP_LE | OP_LT | OP_NE;

//////Operators
//terminal OP_AND : 'and';
//terminal OP_MAX : 'max';
//terminal OP_MIN : 'min';
//terminal OP_MUL : '*';
//terminal OP_OR : 'or';
//terminal OP_XOR : 'xor';
//terminal OP_PLUS : '+';
////Operators that cannot be in reductions
//terminal OP_MINUS : '-';
//terminal OP_DIV : '/';
//terminal OP_MOD : '%';
//terminal OP_NAND : 'nand';
////Relational Operators
//terminal OP_EQ : '=';
//terminal OP_GE : '>=';
//terminal OP_GT : '>';
//terminal OP_LE : '<=';
//terminal OP_LT : '<';
//terminal OP_NE : '!=';

//Constants
terminal BOOLEAN returns ecore::EBoolean: 'true' | 'false';
////terminal INT : ('0'..'9')+;
terminal FLOAT returns ecore::EFloat: ('0'..'9')+ '.' ('0'..'9')+;

//terminal INTERSECTION : '&&';
//
//terminal UNION : '||';

@Override
terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')* |
			"'" ('a'..'z'|'A'..'Z'|'~'|'!'|'@'|'#'|'$'|'%'|'^'|'&'|'*'|'('|')'|'-'|'_'|'+'|'='|'|'|'/'|'?'|'0'..'9')+ "'"
;

@Override	
terminal STRING	: 
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"';

	