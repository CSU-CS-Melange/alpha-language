// automatically generated by Xtext
grammar alpha.model.Alpha with org.eclipse.xtext.common.Terminals

import "alpha.model"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

AlphaRoot:
	imports+=Imports*
	elements+=(AlphaConstant | ExternalFunction | AlphaPackage | AlphaSystem)*
;

AlphaConstant:
	'constant' name=ID '=' value=INT
;

ExternalFunction:
	'external' name=ID '(' cardinality=INT ')'
;

Imports:
	'import' importedNamespace=QualifiedNameWithWildcard
;

AlphaPackage:
	'package' name=QualifiedName '{'
		elements+=(AlphaConstant | ExternalFunction | AlphaPackage | AlphaSystem)*
	'}';

AlphaSystem:
	'affine' name=SystemName parameterDomainExpr=JNIParamDomain
		('define' (definedObjects+=PolyhedralObject)+)?
		('inputs' ( inputs+=Variable | 
					inputs+=VariableNameOnly ',' (inputs+=VariableNameOnly ',')* inputs+=Variable |
					inputs+=FuzzyVariable |
					inputs+=FuzzyVariableNameOnly ',' (inputs+=FuzzyVariableNameOnly ',')* inputs+=FuzzyVariable )+)?
		('outputs' (outputs+=Variable | 
					outputs+=VariableNameOnly ',' (outputs+=VariableNameOnly ',')* outputs+=Variable |
					outputs+=FuzzyVariable |
					outputs+=FuzzyVariableNameOnly ',' (outputs+=FuzzyVariableNameOnly ',')* outputs+=FuzzyVariable )+)?
		('locals' ( locals+=Variable | 
					locals+=VariableNameOnly ',' (locals+=VariableNameOnly ',')* locals+=Variable |
					locals+=FuzzyVariable |
					locals+=FuzzyVariableNameOnly ',' (locals+=FuzzyVariableNameOnly ',')* locals+=FuzzyVariable )+)?
		('over' whileDomainExpr=CalculatorExpression 'while' '(' testExpression=AlphaExpression ')' )?
		systemBodies+=SystemBody*
	'.';
	

SystemBody: {SystemBody}
	('when'  parameterDomainExpr=JNIParamDomainInArrayNotation | 'else' )?
	 'let' 
		(equations+=Equation)*
	
;

Variable:
	name=ID ':' domainExpr=CalculatorExpression ';'?
;

FuzzyVariable:
	'fuzzy' name=ID ':' domainExpr=CalculatorExpression '->' rangeExpr=CalculatorExpression ';'?
;

VariableNameOnly returns Variable:
	name=ID
;

FuzzyVariableNameOnly returns FuzzyVariable:
	name=ID
;

JNIDomain:
	islString=AISLSet
;
JNIDomainInArrayNotation:
	'{' ':' islString=AISLString '}'
;

JNIParamDomain returns JNIDomain:
	islString=AParamDomain
;
JNIParamDomainInArrayNotation returns JNIDomain:
	islString=AParamDomainInArrayNotation
;
JNIRelation:
	islString=AISLRelation
;

JNIFunction:
	alphaFunction=AlphaFunction
;

JNIFunctionInArrayNotation:
	'[' {JNIFunctionInArrayNotation} (arrayNotation+=AISLExpression (',' arrayNotation+=AISLExpression)*)? ']'
;

JNIPolynomial:
	islString=AISLPWQPolynomial;

JNIPolynomialInArrayNotation:	
	'{' arrayNotation+=AISLQPolynomialBody (';' arrayNotation+=AISLQPolynomialBody)* '}';
	
FuzzyFunction:
	'(' alphaString=AISLWrappedBasicRelation (';' indirections+=FuzzyVariableUse)* ')'
;

FuzzyVariableUse:
	NestedFuzzyFunction | AffineFuzzyVariableUse
;

NestedFuzzyFunction:
	fuzzyIndex=IndexName '=' fuzzyVariable=[FuzzyVariable] '{' alphaString=AISLWrappedBasicRelation (';' indirections+=FuzzyVariableUse)* '}'
;

AffineFuzzyVariableUse:
	fuzzyIndex=IndexName '=' fuzzyVariable=[FuzzyVariable] useFunction=JNIFunctionInArrayNotation
;

FuzzyFunctionInArrayNotation:
	'[[' {FuzzyFunctionInArrayNotation} (arrayNotation+=AISLFuzzyExpression (',' arrayNotation+=AISLFuzzyExpression)*)? ']]'
;

QualifiedName:
  ID ('.' ID)*
;
QualifiedNameWithWildcard:
  QualifiedName '.*'?
;

SystemName:
	ID// ('-' ID)*
;

IndexName:
	ID
;

//IndexDimension:
//	name=IndexName
//;

AIndexList:
	(IndexName (',' IndexName)*)?;

//ISL syntax defs

AParamDomain:
	'[' AIndexList ']' '->' '{' ':' AISLString '}' 
;
AParamDomainInArrayNotation:
	'{' ':' AISLString '}' 
;

AISLSet:
	'{' AISLBasicSet (';' AISLBasicSet)* '}' | '{}'
;

AISLBasicSet:
	'[' AISLExpressionList ']' ':' AISLString
;

AISLRelation:
	'{' AISLBasicRelation (';' AISLBasicRelation)* '}'
;

AISLQPolynomial:
	'[' AISLExpressionList ']' '->' AISLQPolynomialBody
;

AISLQPolynomialBody:
	AISLPolynomialExpression (':' AISLString)?
;

AISLPWQPolynomial:
	'{' AISLQPolynomial (';' AISLQPolynomial)* '}'
;

AISLString:
	(IndexName|INT|'+'|'-'|'*'|'/'|'%'|'and'|'or'|'['|']'|'('|')'|','|':'|'&'|'|'|WS|'>='|'>'|'='|'<'|'<=')*;
	
AISLExpression:
	(IndexName|INT|'='|'+'|'-'|'*'|'/'|'%'|'('|')'|WS)+;

AISLPolynomialExpression:
	(IndexName|INT|'+'|'-'|'*'|'/'|'('|')'|'^')+;

AISLExpressionLiteral:
	'-'?(IndexName|INT|WS)+;
AISLExpressionOperator:
	'='|'+'|'-'|'*'|'/'|'%'
;
	
AISLExpressionList:
	(AISLExpression (',' AISLExpression)*)?;

//AAlphaFunction:
//	'[' AIndexList '->' AISLExpressionList ']'
//;

AlphaFunctionTerminalExpression returns AlphaFunctionExpression:
	AlphaFunctionLiteral |
	'(' AlphaFunctionBinaryExpression ')'
;

AlphaFunctionBinaryExpression returns AlphaFunctionExpression:
	AlphaFunctionTerminalExpression ({AlphaFunctionBinaryExpression.left=current} operator=AISLExpressionOperator right=AlphaFunctionTerminalExpression)*
;

AlphaFunctionLiteral returns AlphaFunctionExpression:
	{AlphaFunctionLiteral} value=AISLExpressionLiteral
;

AlphaFunctionExpression:
	AlphaFunctionBinaryExpression
;

AlphaFunction:
	'(' indexList=AIndexList '->' (exprs+=AlphaFunctionExpression (',' exprs+=AlphaFunctionExpression)*)?')'
;

AISLBasicRelation:
	'[' AISLExpressionList ']' '->' '[' AISLExpressionList ']' ':' AISLString
;

AISLWrappedBasicRelation:
	'[' '[' AIndexList ']' '->' '[' AISLExpressionList ']' ']' '->' '[' AISLExpressionList ']'
;

AISLFuzzyExpression:
	(IndexName|INT|'['|']'|'='|'+'|'-'|'*'|'/'|'%'|WS)+;	

//AIndexAffineExpression:	
//	 '-'? AIndexAffineExpressionTerminal (('+'|'-') AIndexAffineExpression)*;
//	
//AIndexAffineExpressionTerminal:
//	(INT | INT? IndexName);


Equation:
	StandardEquation | UseEquation
;

StandardEquation :
	variable=[Variable] ('[' indexNames+=IndexName (',' indexNames+=IndexName)* ']')?  '=' expr=AlphaExpression ';';
	
UseEquation:
	(('over' instantiationDomainExpr=CalculatorExpression)? ('with' ('[' subsystemDims+=IndexName (',' subsystemDims+=IndexName)* ']')?)? ':')? 
	'(' (outputExprs += AlphaExpression (',' outputExprs += AlphaExpression)* )? ')'
	 '=' 
	system=[AlphaSystem|QualifiedName] callParamsExpr=JNIFunctionInArrayNotation
	'(' (inputExprs  += AlphaExpression (',' inputExprs  += AlphaExpression)* )? ')'
	';';
	 	

/* Alpha Expressions */
AlphaExpression:
	IfExpression |
	RestrictExpression |
	AutoRestrictExpression |
	OrExpression
;

AlphaTerminalExpression returns AlphaExpression:
	'(' AlphaExpression ')' |
	CaseExpression |
	ConstantExpression |
	VariableExpression |
	DependenceExpression |
	FuzzyDependenceExpression |
	IndexExpression | 
	PolynomialIndexExpression |	
	FuzzyIndexExpression |
	Reductions |
	ConvolutionExpression |
	MultiArgExpression |
	ExternalMultiArgExpression |
	SelectExpression
;

Reductions returns AlphaExpression:
	ReduceExpression |
	ArgReduceExpression |
	ExternalReduceExpression |
	ExternalArgReduceExpression |
	FuzzyReduceExpression |
	FuzzyArgReduceExpression |
	ExternalFuzzyReduceExpression |
	ExternalFuzzyArgReduceExpression
;

IfExpression:
	'if' condExpr=AlphaExpression
	'then' thenExpr=AlphaExpression
	'else' elseExpr=AlphaExpression
;

RestrictExpression:
	domainExpr=(JNIDomain|JNIDomainInArrayNotation) ':' expr=AlphaExpression |
	'{' domainExpr=CalculatorExpression '}' ':' expr=AlphaExpression
;

AutoRestrictExpression:
	'auto' ':' expr=AlphaExpression
;

CaseExpression : 'case' name=ID? '{'
	(exprs+=AlphaExpression ';' )+
'}';

DependenceExpression:
	functionExpr=JNIFunction '@' expr=AlphaTerminalExpression |
	expr=VariableExpression functionExpr=JNIFunctionInArrayNotation |
	expr=ConstantExpression functionExpr=JNIFunctionInArrayNotation;
	
FuzzyDependenceExpression:
	fuzzyFunction=FuzzyFunction '@' expr=AlphaTerminalExpression |
	expr=VariableExpression fuzzyFunction=FuzzyFunctionInArrayNotation;
		
IndexExpression:
	('val' functionExpr=JNIFunction) |
	('val' functionExpr=JNIFunctionInArrayNotation);
	
PolynomialIndexExpression:
	('val' polynomialExpr=JNIPolynomial )|
	('val' polynomialExpr=JNIPolynomialInArrayNotation);
	
FuzzyIndexExpression:
	'val' fuzzyFunction=FuzzyFunction |
	fuzzyFunction=FuzzyFunctionInArrayNotation;

ReduceExpression:
	'reduce' '(' operator=AREDUCTION_OP ',' 
	projectionExpr=(JNIFunction|JNIFunctionInArrayNotation) ','
	body=AlphaExpression
	 ')'
;
ExternalReduceExpression:
	'reduce' '(' externalFunction=[ExternalFunction|QualifiedName] ',' 
	projectionExpr=(JNIFunction|JNIFunctionInArrayNotation) ','
	body=AlphaExpression
	 ')'
;
ArgReduceExpression : 
	'argreduce' '(' operator=AREDUCTION_OP ',' 
	projectionExpr=(JNIFunction|JNIFunctionInArrayNotation) ','
	body=AlphaExpression
	 ')'
;
ExternalArgReduceExpression:
	'argreduce' '(' externalFunction=[ExternalFunction|QualifiedName] ',' 
	projectionExpr=(JNIFunction|JNIFunctionInArrayNotation) ','
	body=AlphaExpression
	 ')'
;

FuzzyReduceExpression:
	'reduce' '(' operator=AREDUCTION_OP ',' 
	projectionFunction=FuzzyFunction ','
	body=AlphaExpression
	 ')'
;
ExternalFuzzyReduceExpression:
	'reduce' '(' externalFunction=[ExternalFunction|QualifiedName] ',' 
	projectionFunction=FuzzyFunction ','
	body=AlphaExpression
	 ')'
;
FuzzyArgReduceExpression : 
	'argreduce' '(' operator=AREDUCTION_OP ',' 
	projectionFunction=FuzzyFunction ','
	body=AlphaExpression
	 ')'
;
ExternalFuzzyArgReduceExpression:
	'argreduce' '(' externalFunction=[ExternalFunction|QualifiedName] ',' 
	projectionFunction=FuzzyFunction ','
	body=AlphaExpression
	 ')'
;

ConvolutionExpression:
	'conv' '(' kernelDomainExpr=CalculatorExpression ',' 
	kernelExpression=AlphaExpression ','
	dataExpression=AlphaExpression
	 ')'
;

SelectExpression:
	'select' relationExpr=CalculatorExpression 'from' expr=AlphaTerminalExpression
;
	
OrExpression returns AlphaExpression:
	AndExpression ({BinaryExpression.left=current} operator=AOrOP right=AndExpression)*;

AndExpression returns AlphaExpression:
	RelationalExpression ({BinaryExpression.left=current} operator=AAndOP right=RelationalExpression)*;	

RelationalExpression returns AlphaExpression:
	AdditiveExpression ({BinaryExpression.left=current} operator=ARelationalOP right=AdditiveExpression)*;

AdditiveExpression returns AlphaExpression:
	MultiplicativeExpression ({BinaryExpression.left=current} operator=AAdditiveOP right=MultiplicativeExpression)*;

MultiplicativeExpression returns AlphaExpression:
	MinMaxExpression ({BinaryExpression.left=current} operator=AMultiplicativeOP right=MinMaxExpression)*;	

MinMaxExpression returns AlphaExpression:
	UnaryOrTerminalExpression ({BinaryExpression.left=current} operator=AMINMAX_OP right=UnaryOrTerminalExpression)*;

MultiArgExpression:
	operator=AREDUCTION_OP '(' exprs+=AlphaExpression (',' exprs+=AlphaExpression)* ')';
	
ExternalMultiArgExpression:
	externalFunction=[ExternalFunction|QualifiedName] '(' exprs+=AlphaExpression (',' exprs+=AlphaExpression)* ')';	

UnaryOrTerminalExpression returns AlphaExpression:
	UnaryExpression | AlphaTerminalExpression; 
	
UnaryExpression:
	operator=AUnaryOP expr=AlphaTerminalExpression
;

VariableExpression:
	variable=[Variable]
;

ConstantExpression :
	BooleanExpression | RealExpression | IntegerExpression;
	
BooleanExpression :
	value=BOOLEAN;
	
IntegerExpression:
	value=INT;

RealExpression:
	value=FLOAT;	


AREDUCTION_OP returns REDUCTION_OP:
	"min" | "max" | "prod" | "sum" | "and" | "or" | "xor" | "+" | "*"
;

AOrOP returns BINARY_OP:
	"or" | "xor"
;

AAndOP returns BINARY_OP:
	"and"
;

ARelationalOP returns BINARY_OP:
	"=" | "!=" | ">=" | ">" | "<" | "<=";

AAdditiveOP returns BINARY_OP:
	"+" | "-";

AMultiplicativeOP returns BINARY_OP:
	"*" | "/";

AMINMAX_OP returns BINARY_OP:
	"min" | "max";
	
AUnaryOP returns UNARY_OP:
	"not" | "-"
;

/* Calculator Expressions */

PolyhedralObject:
	name=ID '=' expr=CalculatorExpression 
;
CalculatorExpression returns CalculatorExpression:
	UnaryOrTerminalCalculatorExpression ({BinaryCalculatorExpression.left=current} operator=ABinaryCalcOp right=UnaryOrTerminalCalculatorExpression)*
;

UnaryOrTerminalCalculatorExpression returns CalculatorExpression:
	UnaryCalculatorExpression | 
	CalculatorExpressionTerminal
;

CalculatorExpressionTerminal returns CalculatorExpression:
	JNIDomain |
	JNIRelation |
	JNIFunction |
	DefinedObject |
	RectangularDomain |
	VariableDomain | 
	'(' CalculatorExpression ')'
;

UnaryCalculatorExpression:
	operator=AUnaryCalcOp expr=CalculatorExpressionTerminal
;

VariableDomain:
	'{' variable=[Variable] '}'
;
RectangularDomain:
	'[' upperBounds+=AISLExpression (',' upperBounds+=AISLExpression)* ']' ('as' '[' indexNames+=IndexName (',' indexNames+=IndexName)* ']')? |
	'[' lowerBounds+=AISLExpression ':' upperBounds+=AISLExpression (',' lowerBounds+=AISLExpression ':' upperBounds+=AISLExpression)* ']' ('as' '[' indexNames+=IndexName (',' indexNames+=IndexName)* ']')?
;
DefinedObject:
	object=[PolyhedralObject]
;

AUnaryCalcOp returns CALCULATOR_UNARY_OP:
	'domain'|'range'|'complement'|'affine-hull'|'poly-hull'|'reverse'
;

ABinaryCalcOp returns CALCULATOR_BINARY_OP:
	'cross'|'+'|'-'|'*'|'@'|'->-'|'->*' 
;




	
//ARITHMETIC_OP:
//	ARITHMETIC_REDUCTION_OP | ARITHMETIC_NONREDUCTION_OP
//;	
//
//LOGICAL_OP:
//	LOGICAL_REDUCTION_OP | LOGICAL_NONREDUCTION_OP
//;	
//	
//REDUCTION_OP:
//	ARITHMETIC_REDUCTION_OP | LOGICAL_REDUCTION_OP;
//	
//ARITHMETIC_REDUCTION_OP:
//	OP_MAX | OP_MIN | OP_MUL | OP_PLUS;
//	
//LOGICAL_REDUCTION_OP:
//	OP_AND | OP_OR | OP_XOR;
//	
//ARITHMETIC_NONREDUCTION_OP:
//	OP_MINUS | OP_DIV | OP_MOD;
//	
//LOGICAL_NONREDUCTION_OP:
//	OP_NAND;
//	
//RELATIONAL_OP :
//	OP_EQ | OP_GE | OP_GT | OP_LE | OP_LT | OP_NE;

//////Operators
//terminal OP_AND : 'and';
//terminal OP_MAX : 'max';
//terminal OP_MIN : 'min';
//terminal OP_MUL : '*';
//terminal OP_OR : 'or';
//terminal OP_XOR : 'xor';
//terminal OP_PLUS : '+';
////Operators that cannot be in reductions
//terminal OP_MINUS : '-';
//terminal OP_DIV : '/';
//terminal OP_MOD : '%';
//terminal OP_NAND : 'nand';
////Relational Operators
//terminal OP_EQ : '=';
//terminal OP_GE : '>=';
//terminal OP_GT : '>';
//terminal OP_LE : '<=';
//terminal OP_LT : '<';
//terminal OP_NE : '!=';

//Constants
terminal BOOLEAN returns ecore::EBoolean: 'true' | 'false';
////terminal INT : ('0'..'9')+;
terminal FLOAT returns ecore::EFloat: ('0'..'9')+ '.' ('0'..'9')+;

//terminal INTERSECTION : '&&';
//
//terminal UNION : '||';

@Override
terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')* |
			"'" ('a'..'z'|'A'..'Z'|'~'|'!'|'@'|'#'|'$'|'%'|'^'|'&'|'*'|'('|')'|'-'|'_'|'+'|'='|'|'|'/'|'?'|'0'..'9')+ "'"
;

@Override	
terminal STRING	: 
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"';

	