/*
 * generated by Xtext 2.13.0
 */
package alpha.model.serializer;

import alpha.model.AlphaConstant;
import alpha.model.AlphaPackage;
import alpha.model.AlphaRoot;
import alpha.model.AlphaSystem;
import alpha.model.AutoRestrictExpression;
import alpha.model.BinaryCalculatorExpression;
import alpha.model.BinaryExpression;
import alpha.model.BooleanExpression;
import alpha.model.CaseExpression;
import alpha.model.DefinedObject;
import alpha.model.DependenceExpression;
import alpha.model.ExternalFunction;
import alpha.model.ExternalMultiArgExpression;
import alpha.model.ExternalReduceExpression;
import alpha.model.FuzzyVariable;
import alpha.model.IfExpression;
import alpha.model.Imports;
import alpha.model.IndexExpression;
import alpha.model.InputVariable;
import alpha.model.IntegerExpression;
import alpha.model.JNIDomain;
import alpha.model.JNIFunction;
import alpha.model.JNIFunctionInArrayNotation;
import alpha.model.JNIRelation;
import alpha.model.LocalVariable;
import alpha.model.ModelPackage;
import alpha.model.MultiArgExpression;
import alpha.model.OutputVariable;
import alpha.model.PolyhedralObject;
import alpha.model.RealExpression;
import alpha.model.RectangularDomain;
import alpha.model.ReduceExpression;
import alpha.model.RestrictExpression;
import alpha.model.StandardEquation;
import alpha.model.UnaryCalculatorExpression;
import alpha.model.UnaryExpression;
import alpha.model.UseEquation;
import alpha.model.VariableDomain;
import alpha.model.VariableExpression;
import alpha.model.services.AlphaGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AlphaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AlphaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ModelPackage.ALPHA_CONSTANT:
				sequence_AlphaConstant(context, (AlphaConstant) semanticObject); 
				return; 
			case ModelPackage.ALPHA_PACKAGE:
				sequence_AlphaPackage(context, (AlphaPackage) semanticObject); 
				return; 
			case ModelPackage.ALPHA_ROOT:
				sequence_AlphaRoot(context, (AlphaRoot) semanticObject); 
				return; 
			case ModelPackage.ALPHA_SYSTEM:
				sequence_AlphaSystem(context, (AlphaSystem) semanticObject); 
				return; 
			case ModelPackage.AUTO_RESTRICT_EXPRESSION:
				sequence_AutoRestrictExpression(context, (AutoRestrictExpression) semanticObject); 
				return; 
			case ModelPackage.BINARY_CALCULATOR_EXPRESSION:
				sequence_CalculatorExpression(context, (BinaryCalculatorExpression) semanticObject); 
				return; 
			case ModelPackage.BINARY_EXPRESSION:
				sequence_AdditiveExpression_AndExpression_MinMaxExpression_MultiplicativeExpression_OrExpression_RelationalExpression(context, (BinaryExpression) semanticObject); 
				return; 
			case ModelPackage.BOOLEAN_EXPRESSION:
				sequence_BooleanExpression(context, (BooleanExpression) semanticObject); 
				return; 
			case ModelPackage.CASE_EXPRESSION:
				sequence_CaseExpression(context, (CaseExpression) semanticObject); 
				return; 
			case ModelPackage.DEFINED_OBJECT:
				sequence_DefinedObject(context, (DefinedObject) semanticObject); 
				return; 
			case ModelPackage.DEPENDENCE_EXPRESSION:
				sequence_DependenceExpression(context, (DependenceExpression) semanticObject); 
				return; 
			case ModelPackage.EXTERNAL_FUNCTION:
				sequence_ExternalFunction(context, (ExternalFunction) semanticObject); 
				return; 
			case ModelPackage.EXTERNAL_MULTI_ARG_EXPRESSION:
				sequence_ExternalMultiArgExpression(context, (ExternalMultiArgExpression) semanticObject); 
				return; 
			case ModelPackage.EXTERNAL_REDUCE_EXPRESSION:
				sequence_ExternalReduceExpression(context, (ExternalReduceExpression) semanticObject); 
				return; 
			case ModelPackage.FUZZY_VARIABLE:
				sequence_FuzzyVariable(context, (FuzzyVariable) semanticObject); 
				return; 
			case ModelPackage.IF_EXPRESSION:
				sequence_IfExpression(context, (IfExpression) semanticObject); 
				return; 
			case ModelPackage.IMPORTS:
				sequence_Imports(context, (Imports) semanticObject); 
				return; 
			case ModelPackage.INDEX_EXPRESSION:
				sequence_IndexExpression(context, (IndexExpression) semanticObject); 
				return; 
			case ModelPackage.INPUT_VARIABLE:
				sequence_InputVariable(context, (InputVariable) semanticObject); 
				return; 
			case ModelPackage.INTEGER_EXPRESSION:
				sequence_IntegerExpression(context, (IntegerExpression) semanticObject); 
				return; 
			case ModelPackage.JNI_DOMAIN:
				if (rule == grammarAccess.getJNIDomainRule()
						|| rule == grammarAccess.getCalculatorExpressionRule()
						|| action == grammarAccess.getCalculatorExpressionAccess().getBinaryCalculatorExpressionLeftAction_1_0()
						|| rule == grammarAccess.getUnaryOrTerminalCalculatorExpressionRule()
						|| rule == grammarAccess.getCalculatorExpressionTerminalRule()) {
					sequence_JNIDomain(context, (JNIDomain) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJNIParamDomainRule()) {
					sequence_JNIParamDomain(context, (JNIDomain) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.JNI_FUNCTION:
				sequence_JNIFunction(context, (JNIFunction) semanticObject); 
				return; 
			case ModelPackage.JNI_FUNCTION_IN_ARRAY_NOTATION:
				sequence_JNIFunctionInArrayNotation(context, (JNIFunctionInArrayNotation) semanticObject); 
				return; 
			case ModelPackage.JNI_RELATION:
				sequence_JNIRelation(context, (JNIRelation) semanticObject); 
				return; 
			case ModelPackage.LOCAL_VARIABLE:
				sequence_LocalVariable(context, (LocalVariable) semanticObject); 
				return; 
			case ModelPackage.MULTI_ARG_EXPRESSION:
				sequence_MultiArgExpression(context, (MultiArgExpression) semanticObject); 
				return; 
			case ModelPackage.OUTPUT_VARIABLE:
				sequence_OutputVariable(context, (OutputVariable) semanticObject); 
				return; 
			case ModelPackage.POLYHEDRAL_OBJECT:
				sequence_PolyhedralObject(context, (PolyhedralObject) semanticObject); 
				return; 
			case ModelPackage.REAL_EXPRESSION:
				sequence_RealExpression(context, (RealExpression) semanticObject); 
				return; 
			case ModelPackage.RECTANGULAR_DOMAIN:
				sequence_RectangularDomain(context, (RectangularDomain) semanticObject); 
				return; 
			case ModelPackage.REDUCE_EXPRESSION:
				sequence_ReduceExpression(context, (ReduceExpression) semanticObject); 
				return; 
			case ModelPackage.RESTRICT_EXPRESSION:
				sequence_RestrictExpression(context, (RestrictExpression) semanticObject); 
				return; 
			case ModelPackage.STANDARD_EQUATION:
				sequence_StandardEquation(context, (StandardEquation) semanticObject); 
				return; 
			case ModelPackage.UNARY_CALCULATOR_EXPRESSION:
				sequence_UnaryCalculatorExpression(context, (UnaryCalculatorExpression) semanticObject); 
				return; 
			case ModelPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case ModelPackage.USE_EQUATION:
				sequence_UseEquation(context, (UseEquation) semanticObject); 
				return; 
			case ModelPackage.VARIABLE_DOMAIN:
				sequence_VariableDomain(context, (VariableDomain) semanticObject); 
				return; 
			case ModelPackage.VARIABLE_EXPRESSION:
				sequence_VariableExpression(context, (VariableExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AlphaExpression returns BinaryExpression
	 *     AlphaTerminalExpression returns BinaryExpression
	 *     OrExpression returns BinaryExpression
	 *     OrExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     AndExpression returns BinaryExpression
	 *     AndExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     RelationalExpression returns BinaryExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     AdditiveExpression returns BinaryExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     MultiplicativeExpression returns BinaryExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     MinMaxExpression returns BinaryExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     UnaryOrTerminalExpression returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=OrExpression_BinaryExpression_1_0 operator=AOrOP right=AndExpression) | 
	 *         (left=AndExpression_BinaryExpression_1_0 operator=AAndOP right=RelationalExpression) | 
	 *         (left=RelationalExpression_BinaryExpression_1_0 operator=ARelationalOP right=AdditiveExpression) | 
	 *         (left=AdditiveExpression_BinaryExpression_1_0 operator=AAdditiveOP right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_BinaryExpression_1_0 operator=AMultiplicativeOP right=MinMaxExpression) | 
	 *         (left=MinMaxExpression_BinaryExpression_1_0 operator=AMINMAX_OP right=UnaryOrTerminalExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_MinMaxExpression_MultiplicativeExpression_OrExpression_RelationalExpression(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AlphaConstant returns AlphaConstant
	 *
	 * Constraint:
	 *     (name=ID value=INT)
	 */
	protected void sequence_AlphaConstant(ISerializationContext context, AlphaConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ALPHA_CONSTANT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ALPHA_CONSTANT__NAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ALPHA_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ALPHA_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAlphaConstantAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAlphaConstantAccess().getValueINTTerminalRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AlphaPackage returns AlphaPackage
	 *
	 * Constraint:
	 *     (name=QualifiedName (elements+=AlphaConstant | elements+=ExternalFunction | elements+=AlphaPackage | elements+=AlphaSystem)*)
	 */
	protected void sequence_AlphaPackage(ISerializationContext context, AlphaPackage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AlphaRoot returns AlphaRoot
	 *
	 * Constraint:
	 *     (elements+=AlphaConstant | elements+=ExternalFunction | elements+=Imports | elements+=AlphaPackage | elements+=AlphaSystem)+
	 */
	protected void sequence_AlphaRoot(ISerializationContext context, AlphaRoot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AlphaSystem returns AlphaSystem
	 *
	 * Constraint:
	 *     (
	 *         name=SystemName 
	 *         parameterDomain=JNIParamDomain 
	 *         definedObjects+=PolyhedralObject* 
	 *         inputs+=InputVariable* 
	 *         outputs+=OutputVariable* 
	 *         locals+=LocalVariable* 
	 *         fuzzyVariables+=FuzzyVariable* 
	 *         (whileDomain=CalculatorExpression testExpression=AlphaExpression)? 
	 *         useEquations+=UseEquation* 
	 *         equations+=StandardEquation*
	 *     )
	 */
	protected void sequence_AlphaSystem(ISerializationContext context, AlphaSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns AutoRestrictExpression
	 *     AlphaTerminalExpression returns AutoRestrictExpression
	 *     AutoRestrictExpression returns AutoRestrictExpression
	 *     OrExpression returns AutoRestrictExpression
	 *     OrExpression.BinaryExpression_1_0 returns AutoRestrictExpression
	 *     AndExpression returns AutoRestrictExpression
	 *     AndExpression.BinaryExpression_1_0 returns AutoRestrictExpression
	 *     RelationalExpression returns AutoRestrictExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns AutoRestrictExpression
	 *     AdditiveExpression returns AutoRestrictExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns AutoRestrictExpression
	 *     MultiplicativeExpression returns AutoRestrictExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns AutoRestrictExpression
	 *     MinMaxExpression returns AutoRestrictExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns AutoRestrictExpression
	 *     UnaryOrTerminalExpression returns AutoRestrictExpression
	 *
	 * Constraint:
	 *     expr=AlphaExpression
	 */
	protected void sequence_AutoRestrictExpression(ISerializationContext context, AutoRestrictExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.AUTO_RESTRICT_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.AUTO_RESTRICT_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAutoRestrictExpressionAccess().getExprAlphaExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns BooleanExpression
	 *     AlphaTerminalExpression returns BooleanExpression
	 *     OrExpression returns BooleanExpression
	 *     OrExpression.BinaryExpression_1_0 returns BooleanExpression
	 *     AndExpression returns BooleanExpression
	 *     AndExpression.BinaryExpression_1_0 returns BooleanExpression
	 *     RelationalExpression returns BooleanExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns BooleanExpression
	 *     AdditiveExpression returns BooleanExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns BooleanExpression
	 *     MultiplicativeExpression returns BooleanExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns BooleanExpression
	 *     MinMaxExpression returns BooleanExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns BooleanExpression
	 *     UnaryOrTerminalExpression returns BooleanExpression
	 *     ConstantExpression returns BooleanExpression
	 *     BooleanExpression returns BooleanExpression
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_BooleanExpression(ISerializationContext context, BooleanExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.BOOLEAN_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.BOOLEAN_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanExpressionAccess().getValueBOOLEANTerminalRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CalculatorExpression returns BinaryCalculatorExpression
	 *     CalculatorExpression.BinaryCalculatorExpression_1_0 returns BinaryCalculatorExpression
	 *     UnaryOrTerminalCalculatorExpression returns BinaryCalculatorExpression
	 *     CalculatorExpressionTerminal returns BinaryCalculatorExpression
	 *
	 * Constraint:
	 *     (left=CalculatorExpression_BinaryCalculatorExpression_1_0 operator=ABinaryCalcOp right=UnaryOrTerminalCalculatorExpression)
	 */
	protected void sequence_CalculatorExpression(ISerializationContext context, BinaryCalculatorExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.BINARY_CALCULATOR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.BINARY_CALCULATOR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.BINARY_CALCULATOR_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.BINARY_CALCULATOR_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.BINARY_CALCULATOR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.BINARY_CALCULATOR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCalculatorExpressionAccess().getBinaryCalculatorExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCalculatorExpressionAccess().getOperatorABinaryCalcOpParserRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getCalculatorExpressionAccess().getRightUnaryOrTerminalCalculatorExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns CaseExpression
	 *     AlphaTerminalExpression returns CaseExpression
	 *     CaseExpression returns CaseExpression
	 *     OrExpression returns CaseExpression
	 *     OrExpression.BinaryExpression_1_0 returns CaseExpression
	 *     AndExpression returns CaseExpression
	 *     AndExpression.BinaryExpression_1_0 returns CaseExpression
	 *     RelationalExpression returns CaseExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns CaseExpression
	 *     AdditiveExpression returns CaseExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns CaseExpression
	 *     MultiplicativeExpression returns CaseExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns CaseExpression
	 *     MinMaxExpression returns CaseExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns CaseExpression
	 *     UnaryOrTerminalExpression returns CaseExpression
	 *
	 * Constraint:
	 *     (name=ID? exprs+=AlphaExpression+)
	 */
	protected void sequence_CaseExpression(ISerializationContext context, CaseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CalculatorExpression returns DefinedObject
	 *     CalculatorExpression.BinaryCalculatorExpression_1_0 returns DefinedObject
	 *     UnaryOrTerminalCalculatorExpression returns DefinedObject
	 *     CalculatorExpressionTerminal returns DefinedObject
	 *     DefinedObject returns DefinedObject
	 *
	 * Constraint:
	 *     object=[PolyhedralObject|ID]
	 */
	protected void sequence_DefinedObject(ISerializationContext context, DefinedObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.DEFINED_OBJECT__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.DEFINED_OBJECT__OBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefinedObjectAccess().getObjectPolyhedralObjectIDTerminalRuleCall_0_1(), semanticObject.eGet(ModelPackage.Literals.DEFINED_OBJECT__OBJECT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns DependenceExpression
	 *     AlphaTerminalExpression returns DependenceExpression
	 *     DependenceExpression returns DependenceExpression
	 *     OrExpression returns DependenceExpression
	 *     OrExpression.BinaryExpression_1_0 returns DependenceExpression
	 *     AndExpression returns DependenceExpression
	 *     AndExpression.BinaryExpression_1_0 returns DependenceExpression
	 *     RelationalExpression returns DependenceExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns DependenceExpression
	 *     AdditiveExpression returns DependenceExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns DependenceExpression
	 *     MultiplicativeExpression returns DependenceExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns DependenceExpression
	 *     MinMaxExpression returns DependenceExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns DependenceExpression
	 *     UnaryOrTerminalExpression returns DependenceExpression
	 *
	 * Constraint:
	 *     ((function=JNIFunction expr=AlphaTerminalExpression) | (expr=VariableExpression function=JNIFunctionInArrayNotation))
	 */
	protected void sequence_DependenceExpression(ISerializationContext context, DependenceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExternalFunction returns ExternalFunction
	 *
	 * Constraint:
	 *     (name=ID cardinarity=INT)
	 */
	protected void sequence_ExternalFunction(ISerializationContext context, ExternalFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.EXTERNAL_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.EXTERNAL_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.EXTERNAL_FUNCTION__CARDINARITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.EXTERNAL_FUNCTION__CARDINARITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternalFunctionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExternalFunctionAccess().getCardinarityINTTerminalRuleCall_3_0(), semanticObject.getCardinarity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns ExternalMultiArgExpression
	 *     AlphaTerminalExpression returns ExternalMultiArgExpression
	 *     OrExpression returns ExternalMultiArgExpression
	 *     OrExpression.BinaryExpression_1_0 returns ExternalMultiArgExpression
	 *     AndExpression returns ExternalMultiArgExpression
	 *     AndExpression.BinaryExpression_1_0 returns ExternalMultiArgExpression
	 *     RelationalExpression returns ExternalMultiArgExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns ExternalMultiArgExpression
	 *     AdditiveExpression returns ExternalMultiArgExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns ExternalMultiArgExpression
	 *     MultiplicativeExpression returns ExternalMultiArgExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns ExternalMultiArgExpression
	 *     MinMaxExpression returns ExternalMultiArgExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns ExternalMultiArgExpression
	 *     ExternalMultiArgExpression returns ExternalMultiArgExpression
	 *     UnaryOrTerminalExpression returns ExternalMultiArgExpression
	 *
	 * Constraint:
	 *     (externalFunction=[ExternalFunction|ID] exprs+=AlphaExpression exprs+=AlphaExpression+)
	 */
	protected void sequence_ExternalMultiArgExpression(ISerializationContext context, ExternalMultiArgExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns ExternalReduceExpression
	 *     AlphaTerminalExpression returns ExternalReduceExpression
	 *     ExternalReduceExpression returns ExternalReduceExpression
	 *     OrExpression returns ExternalReduceExpression
	 *     OrExpression.BinaryExpression_1_0 returns ExternalReduceExpression
	 *     AndExpression returns ExternalReduceExpression
	 *     AndExpression.BinaryExpression_1_0 returns ExternalReduceExpression
	 *     RelationalExpression returns ExternalReduceExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns ExternalReduceExpression
	 *     AdditiveExpression returns ExternalReduceExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns ExternalReduceExpression
	 *     MultiplicativeExpression returns ExternalReduceExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns ExternalReduceExpression
	 *     MinMaxExpression returns ExternalReduceExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns ExternalReduceExpression
	 *     UnaryOrTerminalExpression returns ExternalReduceExpression
	 *
	 * Constraint:
	 *     (externalFunction=[ExternalFunction|ID] (projection=JNIFunction | projection=JNIFunctionInArrayNotation) body=AlphaExpression)
	 */
	protected void sequence_ExternalReduceExpression(ISerializationContext context, ExternalReduceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FuzzyVariable returns FuzzyVariable
	 *
	 * Constraint:
	 *     (name=ID domainExpr=CalculatorExpression?)
	 */
	protected void sequence_FuzzyVariable(ISerializationContext context, FuzzyVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns IfExpression
	 *     AlphaTerminalExpression returns IfExpression
	 *     IfExpression returns IfExpression
	 *     OrExpression returns IfExpression
	 *     OrExpression.BinaryExpression_1_0 returns IfExpression
	 *     AndExpression returns IfExpression
	 *     AndExpression.BinaryExpression_1_0 returns IfExpression
	 *     RelationalExpression returns IfExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns IfExpression
	 *     AdditiveExpression returns IfExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns IfExpression
	 *     MultiplicativeExpression returns IfExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns IfExpression
	 *     MinMaxExpression returns IfExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns IfExpression
	 *     UnaryOrTerminalExpression returns IfExpression
	 *
	 * Constraint:
	 *     (condExpr=AlphaExpression thenExpr=AlphaExpression elseExpr=AlphaExpression)
	 */
	protected void sequence_IfExpression(ISerializationContext context, IfExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IF_EXPRESSION__COND_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IF_EXPRESSION__COND_EXPR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IF_EXPRESSION__THEN_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IF_EXPRESSION__THEN_EXPR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IF_EXPRESSION__ELSE_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IF_EXPRESSION__ELSE_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfExpressionAccess().getCondExprAlphaExpressionParserRuleCall_1_0(), semanticObject.getCondExpr());
		feeder.accept(grammarAccess.getIfExpressionAccess().getThenExprAlphaExpressionParserRuleCall_3_0(), semanticObject.getThenExpr());
		feeder.accept(grammarAccess.getIfExpressionAccess().getElseExprAlphaExpressionParserRuleCall_5_0(), semanticObject.getElseExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Imports returns Imports
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Imports(ISerializationContext context, Imports semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IMPORTS__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IMPORTS__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportsAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns IndexExpression
	 *     AlphaTerminalExpression returns IndexExpression
	 *     IndexExpression returns IndexExpression
	 *     OrExpression returns IndexExpression
	 *     OrExpression.BinaryExpression_1_0 returns IndexExpression
	 *     AndExpression returns IndexExpression
	 *     AndExpression.BinaryExpression_1_0 returns IndexExpression
	 *     RelationalExpression returns IndexExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns IndexExpression
	 *     AdditiveExpression returns IndexExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns IndexExpression
	 *     MultiplicativeExpression returns IndexExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns IndexExpression
	 *     MinMaxExpression returns IndexExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns IndexExpression
	 *     UnaryOrTerminalExpression returns IndexExpression
	 *
	 * Constraint:
	 *     (function=JNIFunction | function=JNIFunctionInArrayNotation)
	 */
	protected void sequence_IndexExpression(ISerializationContext context, IndexExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputVariable returns InputVariable
	 *
	 * Constraint:
	 *     (name=ID domainExpr=CalculatorExpression?)
	 */
	protected void sequence_InputVariable(ISerializationContext context, InputVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns IntegerExpression
	 *     AlphaTerminalExpression returns IntegerExpression
	 *     OrExpression returns IntegerExpression
	 *     OrExpression.BinaryExpression_1_0 returns IntegerExpression
	 *     AndExpression returns IntegerExpression
	 *     AndExpression.BinaryExpression_1_0 returns IntegerExpression
	 *     RelationalExpression returns IntegerExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns IntegerExpression
	 *     AdditiveExpression returns IntegerExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns IntegerExpression
	 *     MultiplicativeExpression returns IntegerExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns IntegerExpression
	 *     MinMaxExpression returns IntegerExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns IntegerExpression
	 *     UnaryOrTerminalExpression returns IntegerExpression
	 *     ConstantExpression returns IntegerExpression
	 *     IntegerExpression returns IntegerExpression
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntegerExpression(ISerializationContext context, IntegerExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.INTEGER_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.INTEGER_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerExpressionAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JNIDomain returns JNIDomain
	 *     CalculatorExpression returns JNIDomain
	 *     CalculatorExpression.BinaryCalculatorExpression_1_0 returns JNIDomain
	 *     UnaryOrTerminalCalculatorExpression returns JNIDomain
	 *     CalculatorExpressionTerminal returns JNIDomain
	 *
	 * Constraint:
	 *     islString=AISLSet
	 */
	protected void sequence_JNIDomain(ISerializationContext context, JNIDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.JNI_DOMAIN__ISL_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.JNI_DOMAIN__ISL_STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJNIDomainAccess().getIslStringAISLSetParserRuleCall_0(), semanticObject.getIslString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JNIFunctionInArrayNotation returns JNIFunctionInArrayNotation
	 *
	 * Constraint:
	 *     arrayNotation=AAlphaFunctionInArrayNotation
	 */
	protected void sequence_JNIFunctionInArrayNotation(ISerializationContext context, JNIFunctionInArrayNotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.JNI_FUNCTION_IN_ARRAY_NOTATION__ARRAY_NOTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.JNI_FUNCTION_IN_ARRAY_NOTATION__ARRAY_NOTATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJNIFunctionInArrayNotationAccess().getArrayNotationAAlphaFunctionInArrayNotationParserRuleCall_0(), semanticObject.getArrayNotation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JNIFunction returns JNIFunction
	 *     CalculatorExpression returns JNIFunction
	 *     CalculatorExpression.BinaryCalculatorExpression_1_0 returns JNIFunction
	 *     UnaryOrTerminalCalculatorExpression returns JNIFunction
	 *     CalculatorExpressionTerminal returns JNIFunction
	 *
	 * Constraint:
	 *     alphaString=AAlphaFunction
	 */
	protected void sequence_JNIFunction(ISerializationContext context, JNIFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.JNI_FUNCTION__ALPHA_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.JNI_FUNCTION__ALPHA_STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJNIFunctionAccess().getAlphaStringAAlphaFunctionParserRuleCall_0(), semanticObject.getAlphaString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JNIParamDomain returns JNIDomain
	 *
	 * Constraint:
	 *     islString=AParamDomain
	 */
	protected void sequence_JNIParamDomain(ISerializationContext context, JNIDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.JNI_DOMAIN__ISL_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.JNI_DOMAIN__ISL_STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJNIParamDomainAccess().getIslStringAParamDomainParserRuleCall_0(), semanticObject.getIslString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JNIRelation returns JNIRelation
	 *     CalculatorExpression returns JNIRelation
	 *     CalculatorExpression.BinaryCalculatorExpression_1_0 returns JNIRelation
	 *     UnaryOrTerminalCalculatorExpression returns JNIRelation
	 *     CalculatorExpressionTerminal returns JNIRelation
	 *
	 * Constraint:
	 *     islString=AISLRelation
	 */
	protected void sequence_JNIRelation(ISerializationContext context, JNIRelation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.JNI_RELATION__ISL_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.JNI_RELATION__ISL_STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJNIRelationAccess().getIslStringAISLRelationParserRuleCall_0(), semanticObject.getIslString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LocalVariable returns LocalVariable
	 *
	 * Constraint:
	 *     (name=ID domainExpr=CalculatorExpression?)
	 */
	protected void sequence_LocalVariable(ISerializationContext context, LocalVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns MultiArgExpression
	 *     AlphaTerminalExpression returns MultiArgExpression
	 *     OrExpression returns MultiArgExpression
	 *     OrExpression.BinaryExpression_1_0 returns MultiArgExpression
	 *     AndExpression returns MultiArgExpression
	 *     AndExpression.BinaryExpression_1_0 returns MultiArgExpression
	 *     RelationalExpression returns MultiArgExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns MultiArgExpression
	 *     AdditiveExpression returns MultiArgExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns MultiArgExpression
	 *     MultiplicativeExpression returns MultiArgExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns MultiArgExpression
	 *     MinMaxExpression returns MultiArgExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns MultiArgExpression
	 *     MultiArgExpression returns MultiArgExpression
	 *     UnaryOrTerminalExpression returns MultiArgExpression
	 *
	 * Constraint:
	 *     (operator=AREDUCTION_OP exprs+=AlphaExpression exprs+=AlphaExpression+)
	 */
	protected void sequence_MultiArgExpression(ISerializationContext context, MultiArgExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputVariable returns OutputVariable
	 *
	 * Constraint:
	 *     (name=ID domainExpr=CalculatorExpression?)
	 */
	protected void sequence_OutputVariable(ISerializationContext context, OutputVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolyhedralObject returns PolyhedralObject
	 *
	 * Constraint:
	 *     (name=ID expr=CalculatorExpression)
	 */
	protected void sequence_PolyhedralObject(ISerializationContext context, PolyhedralObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.POLYHEDRAL_OBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.POLYHEDRAL_OBJECT__NAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.POLYHEDRAL_OBJECT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.POLYHEDRAL_OBJECT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPolyhedralObjectAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPolyhedralObjectAccess().getExprCalculatorExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns RealExpression
	 *     AlphaTerminalExpression returns RealExpression
	 *     OrExpression returns RealExpression
	 *     OrExpression.BinaryExpression_1_0 returns RealExpression
	 *     AndExpression returns RealExpression
	 *     AndExpression.BinaryExpression_1_0 returns RealExpression
	 *     RelationalExpression returns RealExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns RealExpression
	 *     AdditiveExpression returns RealExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns RealExpression
	 *     MultiplicativeExpression returns RealExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns RealExpression
	 *     MinMaxExpression returns RealExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns RealExpression
	 *     UnaryOrTerminalExpression returns RealExpression
	 *     ConstantExpression returns RealExpression
	 *     RealExpression returns RealExpression
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_RealExpression(ISerializationContext context, RealExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.REAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.REAL_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealExpressionAccess().getValueFLOATTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CalculatorExpression returns RectangularDomain
	 *     CalculatorExpression.BinaryCalculatorExpression_1_0 returns RectangularDomain
	 *     UnaryOrTerminalCalculatorExpression returns RectangularDomain
	 *     CalculatorExpressionTerminal returns RectangularDomain
	 *     RectangularDomain returns RectangularDomain
	 *
	 * Constraint:
	 *     (upperBounds+=IndexName upperBounds+=IndexName* (indexNames+=IndexName indexNames+=IndexName*)?)
	 */
	protected void sequence_RectangularDomain(ISerializationContext context, RectangularDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns ReduceExpression
	 *     AlphaTerminalExpression returns ReduceExpression
	 *     ReduceExpression returns ReduceExpression
	 *     OrExpression returns ReduceExpression
	 *     OrExpression.BinaryExpression_1_0 returns ReduceExpression
	 *     AndExpression returns ReduceExpression
	 *     AndExpression.BinaryExpression_1_0 returns ReduceExpression
	 *     RelationalExpression returns ReduceExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns ReduceExpression
	 *     AdditiveExpression returns ReduceExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns ReduceExpression
	 *     MultiplicativeExpression returns ReduceExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns ReduceExpression
	 *     MinMaxExpression returns ReduceExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns ReduceExpression
	 *     UnaryOrTerminalExpression returns ReduceExpression
	 *
	 * Constraint:
	 *     (operator=AREDUCTION_OP (projection=JNIFunction | projection=JNIFunctionInArrayNotation) body=AlphaExpression)
	 */
	protected void sequence_ReduceExpression(ISerializationContext context, ReduceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns RestrictExpression
	 *     AlphaTerminalExpression returns RestrictExpression
	 *     RestrictExpression returns RestrictExpression
	 *     OrExpression returns RestrictExpression
	 *     OrExpression.BinaryExpression_1_0 returns RestrictExpression
	 *     AndExpression returns RestrictExpression
	 *     AndExpression.BinaryExpression_1_0 returns RestrictExpression
	 *     RelationalExpression returns RestrictExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns RestrictExpression
	 *     AdditiveExpression returns RestrictExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns RestrictExpression
	 *     MultiplicativeExpression returns RestrictExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns RestrictExpression
	 *     MinMaxExpression returns RestrictExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns RestrictExpression
	 *     UnaryOrTerminalExpression returns RestrictExpression
	 *
	 * Constraint:
	 *     ((domainExpr=JNIDomain expr=AlphaExpression) | (domainExpr=CalculatorExpression expr=AlphaExpression))
	 */
	protected void sequence_RestrictExpression(ISerializationContext context, RestrictExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StandardEquation returns StandardEquation
	 *
	 * Constraint:
	 *     (variable=[Variable|ID] (indexNames+=IndexName indexNames+=IndexName*)? expr=AlphaExpression)
	 */
	protected void sequence_StandardEquation(ISerializationContext context, StandardEquation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CalculatorExpression returns UnaryCalculatorExpression
	 *     CalculatorExpression.BinaryCalculatorExpression_1_0 returns UnaryCalculatorExpression
	 *     UnaryOrTerminalCalculatorExpression returns UnaryCalculatorExpression
	 *     CalculatorExpressionTerminal returns UnaryCalculatorExpression
	 *     UnaryCalculatorExpression returns UnaryCalculatorExpression
	 *
	 * Constraint:
	 *     (operator=AUnaryCalcOp expr=CalculatorExpressionTerminal)
	 */
	protected void sequence_UnaryCalculatorExpression(ISerializationContext context, UnaryCalculatorExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.UNARY_CALCULATOR_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.UNARY_CALCULATOR_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.UNARY_CALCULATOR_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.UNARY_CALCULATOR_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryCalculatorExpressionAccess().getOperatorAUnaryCalcOpParserRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getUnaryCalculatorExpressionAccess().getExprCalculatorExpressionTerminalParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns UnaryExpression
	 *     AlphaTerminalExpression returns UnaryExpression
	 *     OrExpression returns UnaryExpression
	 *     OrExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     AndExpression returns UnaryExpression
	 *     AndExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     RelationalExpression returns UnaryExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     AdditiveExpression returns UnaryExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     MultiplicativeExpression returns UnaryExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     MinMaxExpression returns UnaryExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     UnaryOrTerminalExpression returns UnaryExpression
	 *     UnaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (operator=AUnaryOP expr=AlphaTerminalExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.UNARY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.UNARY_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.UNARY_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.UNARY_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOperatorAUnaryOPParserRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getExprAlphaTerminalExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UseEquation returns UseEquation
	 *
	 * Constraint:
	 *     (
	 *         (instantiationDomain=CalculatorExpression (subsystemDims+=IndexName subsystemDims+=IndexName*)?)? 
	 *         (outputExprs+=AlphaExpression outputExprs+=AlphaExpression*)? 
	 *         system=[AlphaSystem|ID] 
	 *         callParams=JNIFunctionInArrayNotation 
	 *         (inputExprs+=AlphaExpression inputExprs+=AlphaExpression*)?
	 *     )
	 */
	protected void sequence_UseEquation(ISerializationContext context, UseEquation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CalculatorExpression returns VariableDomain
	 *     CalculatorExpression.BinaryCalculatorExpression_1_0 returns VariableDomain
	 *     UnaryOrTerminalCalculatorExpression returns VariableDomain
	 *     CalculatorExpressionTerminal returns VariableDomain
	 *     VariableDomain returns VariableDomain
	 *
	 * Constraint:
	 *     variable=[Variable|ID]
	 */
	protected void sequence_VariableDomain(ISerializationContext context, VariableDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.VARIABLE_DOMAIN__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.VARIABLE_DOMAIN__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDomainAccess().getVariableVariableIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ModelPackage.Literals.VARIABLE_DOMAIN__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AlphaExpression returns VariableExpression
	 *     AlphaTerminalExpression returns VariableExpression
	 *     OrExpression returns VariableExpression
	 *     OrExpression.BinaryExpression_1_0 returns VariableExpression
	 *     AndExpression returns VariableExpression
	 *     AndExpression.BinaryExpression_1_0 returns VariableExpression
	 *     RelationalExpression returns VariableExpression
	 *     RelationalExpression.BinaryExpression_1_0 returns VariableExpression
	 *     AdditiveExpression returns VariableExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns VariableExpression
	 *     MultiplicativeExpression returns VariableExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns VariableExpression
	 *     MinMaxExpression returns VariableExpression
	 *     MinMaxExpression.BinaryExpression_1_0 returns VariableExpression
	 *     UnaryOrTerminalExpression returns VariableExpression
	 *     VariableExpression returns VariableExpression
	 *
	 * Constraint:
	 *     variable=[Variable|ID]
	 */
	protected void sequence_VariableExpression(ISerializationContext context, VariableExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.VARIABLE_EXPRESSION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.VARIABLE_EXPRESSION__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableExpressionAccess().getVariableVariableIDTerminalRuleCall_0_1(), semanticObject.eGet(ModelPackage.Literals.VARIABLE_EXPRESSION__VARIABLE, false));
		feeder.finish();
	}
	
	
}
