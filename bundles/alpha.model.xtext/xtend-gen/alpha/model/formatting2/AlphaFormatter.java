/**
 * generated by Xtext 2.13.0
 */
package alpha.model.formatting2;

import alpha.model.AlphaElement;
import alpha.model.AlphaExpression;
import alpha.model.AlphaPackage;
import alpha.model.AlphaRoot;
import alpha.model.AlphaSystem;
import alpha.model.CalculatorExpression;
import alpha.model.CaseExpression;
import alpha.model.FuzzyVariable;
import alpha.model.PolyhedralObject;
import alpha.model.StandardEquation;
import alpha.model.UseEquation;
import alpha.model.Variable;
import alpha.model.services.AlphaGrammarAccess;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.formatting2.AbstractFormatter2;
import org.eclipse.xtext.formatting2.IFormattableDocument;
import org.eclipse.xtext.formatting2.IHiddenRegionFormatter;
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

@SuppressWarnings("all")
public class AlphaFormatter extends AbstractFormatter2 {
  @Inject
  @Extension
  private AlphaGrammarAccess _alphaGrammarAccess;
  
  protected void _format(final AlphaRoot alphaRoot, @Extension final IFormattableDocument document) {
    EList<AlphaElement> _elements = alphaRoot.getElements();
    for (final AlphaElement alphaElement : _elements) {
      document.<AlphaElement>format(alphaElement);
    }
  }
  
  protected void _format(final AlphaPackage alphaPackage, @Extension final IFormattableDocument document) {
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.newLine();
    };
    document.append(this.textRegionExtensions.regionFor(alphaPackage).keyword(this._alphaGrammarAccess.getAlphaPackageAccess().getLeftCurlyBracketKeyword_2()), _function);
    final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
      it.indent();
    };
    document.<AlphaPackage>interior(alphaPackage, _function_1);
    EList<AlphaElement> _elements = alphaPackage.getElements();
    for (final AlphaElement alphaElement : _elements) {
      document.<AlphaElement>format(alphaElement);
    }
  }
  
  private void newLineAndIndent(final EObject element, final Object start, final Object end, @Extension final IFormattableDocument document) {
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.newLine();
    };
    document.surround(this.getISemanticRegion(element, start), _function);
    final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
      it.indent();
    };
    document.<ISemanticRegion, ISemanticRegion>interior(this.getISemanticRegion(element, start), this.getISemanticRegion(element, end), _function_1);
  }
  
  private ISemanticRegion _getISemanticRegion(final EObject element, final String obj) {
    return this.textRegionExtensions.regionFor(element).keyword(obj);
  }
  
  private ISemanticRegion _getISemanticRegion(final EObject element, final Keyword obj) {
    return this.textRegionExtensions.regionFor(element).keyword(obj);
  }
  
  private ISemanticRegion _getISemanticRegion(final EObject element, final EStructuralFeature obj) {
    return this.textRegionExtensions.regionFor(element).feature(obj);
  }
  
  private final static ArrayList<String> SysKWs = CollectionLiterals.<String>newArrayList("define", "inputs", "outputs", "locals", "fuzzy", "over", "let", ".");
  
  private String getNextApplicableKeyword(final AlphaSystem system, final String keyword) {
    boolean _switchResult = false;
    if (keyword != null) {
      switch (keyword) {
        case "define":
          _switchResult = system.getInputs().isEmpty();
          break;
        case "inputs":
          _switchResult = system.getOutputs().isEmpty();
          break;
        case "outputs":
          _switchResult = system.getLocals().isEmpty();
          break;
        case "locals":
          _switchResult = system.getFuzzyVariables().isEmpty();
          break;
        case "fuzzy":
          CalculatorExpression _whileDomainExpr = system.getWhileDomainExpr();
          _switchResult = (_whileDomainExpr == null);
          break;
        case "over":
          _switchResult = (system.getEquations().isEmpty() && system.getUseEquations().isEmpty());
          break;
        default:
          _switchResult = false;
          break;
      }
    } else {
      _switchResult = false;
    }
    final boolean isEmpty = _switchResult;
    String _xifexpression = null;
    if (isEmpty) {
      _xifexpression = this.getNextApplicableKeyword(system, this.next(keyword));
    } else {
      _xifexpression = this.next(keyword);
    }
    return _xifexpression;
  }
  
  private String next(final String current) {
    final int index = AlphaFormatter.SysKWs.indexOf(current);
    if (((index == (-1)) || (index == 7))) {
      return null;
    }
    return AlphaFormatter.SysKWs.get((index + 1));
  }
  
  protected void _format(final AlphaSystem alphaSystem, @Extension final IFormattableDocument document) {
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.indent();
    };
    document.<AlphaSystem>interior(alphaSystem, _function);
    String current = "define";
    while ((!Objects.equal(current, "."))) {
      {
        final String next = this.getNextApplicableKeyword(alphaSystem, current);
        this.newLineAndIndent(alphaSystem, current, next, document);
        current = next;
      }
    }
    EList<Variable> _variables = alphaSystem.getVariables();
    for (final Variable variable : _variables) {
      {
        document.<Variable>format(variable);
        final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
          it.newLine();
        };
        document.<Variable>append(variable, _function_1);
      }
    }
    EList<FuzzyVariable> _fuzzyVariables = alphaSystem.getFuzzyVariables();
    for (final FuzzyVariable variable_1 : _fuzzyVariables) {
      {
        document.<FuzzyVariable>format(variable_1);
        final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
          it.newLine();
        };
        document.<FuzzyVariable>append(variable_1, _function_1);
      }
    }
    EList<PolyhedralObject> _definedObjects = alphaSystem.getDefinedObjects();
    for (final PolyhedralObject pobj : _definedObjects) {
      {
        document.<PolyhedralObject>format(pobj);
        final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
          it.newLine();
        };
        document.<PolyhedralObject>append(pobj, _function_1);
      }
    }
    EList<StandardEquation> _equations = alphaSystem.getEquations();
    for (final StandardEquation eq : _equations) {
      {
        document.<StandardEquation>format(eq);
        final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
          it.newLine();
        };
        document.<StandardEquation>append(eq, _function_1);
      }
    }
    EList<UseEquation> _useEquations = alphaSystem.getUseEquations();
    for (final UseEquation eq_1 : _useEquations) {
      {
        document.<UseEquation>format(eq_1);
        final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
          it.newLine();
        };
        document.<UseEquation>append(eq_1, _function_1);
      }
    }
  }
  
  protected void _format(final Variable v, @Extension final IFormattableDocument document) {
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.oneSpace();
    };
    document.surround(this.textRegionExtensions.regionFor(v).keyword(":"), _function);
  }
  
  protected void _format(final StandardEquation eq, @Extension final IFormattableDocument document) {
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.noSpace();
    };
    document.prepend(this.textRegionExtensions.regionFor(eq).keyword(";"), _function);
    document.<AlphaExpression>format(eq.getExpr());
  }
  
  private void formatChildren(final AlphaExpression expr, @Extension final IFormattableDocument document) {
    Iterable<AlphaExpression> _filter = Iterables.<AlphaExpression>filter(expr.eContents(), AlphaExpression.class);
    for (final AlphaExpression child : _filter) {
      document.<AlphaExpression>format(child);
    }
  }
  
  protected void _format(final AlphaExpression expr, @Extension final IFormattableDocument document) {
    this.formatChildren(expr, document);
  }
  
  protected void _format(final CaseExpression caseExpr, @Extension final IFormattableDocument document) {
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.oneSpace();
    };
    final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
      it.newLine();
    };
    document.append(document.prepend(this.textRegionExtensions.regionFor(caseExpr).keyword("{"), _function), _function_1);
    final Procedure1<IHiddenRegionFormatter> _function_2 = (IHiddenRegionFormatter it) -> {
      it.newLine();
    };
    final Procedure1<IHiddenRegionFormatter> _function_3 = (IHiddenRegionFormatter it) -> {
      it.noSpace();
    };
    document.append(document.prepend(this.textRegionExtensions.regionFor(caseExpr).keyword("}"), _function_2), _function_3);
    final Procedure1<IHiddenRegionFormatter> _function_4 = (IHiddenRegionFormatter it) -> {
      it.indent();
    };
    document.<CaseExpression>interior(caseExpr, _function_4);
    final Consumer<ISemanticRegion> _function_5 = (ISemanticRegion it) -> {
      final Procedure1<IHiddenRegionFormatter> _function_6 = (IHiddenRegionFormatter it_1) -> {
        it_1.newLine();
      };
      document.append(it, _function_6);
    };
    this.textRegionExtensions.allRegionsFor(caseExpr).keywords(";").forEach(_function_5);
    this.formatChildren(caseExpr, document);
  }
  
  public void format(final Object alphaPackage, final IFormattableDocument document) {
    if (alphaPackage instanceof AlphaPackage) {
      _format((AlphaPackage)alphaPackage, document);
      return;
    } else if (alphaPackage instanceof AlphaSystem) {
      _format((AlphaSystem)alphaPackage, document);
      return;
    } else if (alphaPackage instanceof CaseExpression) {
      _format((CaseExpression)alphaPackage, document);
      return;
    } else if (alphaPackage instanceof AlphaExpression) {
      _format((AlphaExpression)alphaPackage, document);
      return;
    } else if (alphaPackage instanceof AlphaRoot) {
      _format((AlphaRoot)alphaPackage, document);
      return;
    } else if (alphaPackage instanceof StandardEquation) {
      _format((StandardEquation)alphaPackage, document);
      return;
    } else if (alphaPackage instanceof Variable) {
      _format((Variable)alphaPackage, document);
      return;
    } else if (alphaPackage instanceof XtextResource) {
      _format((XtextResource)alphaPackage, document);
      return;
    } else if (alphaPackage instanceof EObject) {
      _format((EObject)alphaPackage, document);
      return;
    } else if (alphaPackage == null) {
      _format((Void)null, document);
      return;
    } else if (alphaPackage != null) {
      _format(alphaPackage, document);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(alphaPackage, document).toString());
    }
  }
  
  private ISemanticRegion getISemanticRegion(final EObject element, final Object obj) {
    if (obj instanceof EStructuralFeature) {
      return _getISemanticRegion(element, (EStructuralFeature)obj);
    } else if (obj instanceof Keyword) {
      return _getISemanticRegion(element, (Keyword)obj);
    } else if (obj instanceof String) {
      return _getISemanticRegion(element, (String)obj);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(element, obj).toString());
    }
  }
}
