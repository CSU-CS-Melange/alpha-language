/*
 * generated by Xtext 2.13.0
 */
package alpha.serializer;

import alpha.alpha.AAdditiveExpression;
import alpha.alpha.AAffineSystem;
import alpha.alpha.AAndExpression;
import alpha.alpha.AArgReduceExpression;
import alpha.alpha.AAutoRestrictExpression;
import alpha.alpha.ABinaryPolyObjExpression;
import alpha.alpha.ABooleanExpression;
import alpha.alpha.ACaseExpression;
import alpha.alpha.AConstant;
import alpha.alpha.AConvExpression;
import alpha.alpha.ADeclaredObject;
import alpha.alpha.ADependenceExpression;
import alpha.alpha.ADependenceInArrayNotation;
import alpha.alpha.AEquation;
import alpha.alpha.AExternalFunction;
import alpha.alpha.AExternalFunctionCall;
import alpha.alpha.AFunction;
import alpha.alpha.AFunctionInArrayNotation;
import alpha.alpha.AFuzzyVariableDeclaration;
import alpha.alpha.AISLBasicRelation;
import alpha.alpha.AISLBasicSet;
import alpha.alpha.AISLRelation;
import alpha.alpha.AISLSet;
import alpha.alpha.AIfExpression;
import alpha.alpha.AImport;
import alpha.alpha.AIndexAffineExpressionList;
import alpha.alpha.AIndexExpression;
import alpha.alpha.AIndexExpressionInArrayNotation;
import alpha.alpha.AIntegerExpression;
import alpha.alpha.AMinMaxExpression;
import alpha.alpha.AMultiArgArithmeticExpression;
import alpha.alpha.AMultiArgLogicalExpression;
import alpha.alpha.AMultiplicativeExpression;
import alpha.alpha.ANegateExpression;
import alpha.alpha.ANotExpression;
import alpha.alpha.AOrExpression;
import alpha.alpha.APackageDeclaration;
import alpha.alpha.APolyhedralObjectExpression;
import alpha.alpha.ARealExpression;
import alpha.alpha.ARectangularDomain;
import alpha.alpha.AReduceExpression;
import alpha.alpha.AReductionOperator;
import alpha.alpha.ARelationalExpression;
import alpha.alpha.ARestrictExpression;
import alpha.alpha.ASelectDependenceExpression;
import alpha.alpha.AStart;
import alpha.alpha.AUseEquation;
import alpha.alpha.AVariable;
import alpha.alpha.AVariableDeclaration;
import alpha.alpha.AVariableDomain;
import alpha.alpha.AVariableExpression;
import alpha.alpha.AVariableList;
import alpha.alpha.AlphaPackage;
import alpha.alpha.PolyhedralObject;
import alpha.services.AlphaGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AlphaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AlphaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AlphaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AlphaPackage.AADDITIVE_EXPRESSION:
				sequence_AAdditiveExpression(context, (AAdditiveExpression) semanticObject); 
				return; 
			case AlphaPackage.AAFFINE_SYSTEM:
				sequence_AAffineSystem(context, (AAffineSystem) semanticObject); 
				return; 
			case AlphaPackage.AAND_EXPRESSION:
				sequence_AAndExpression(context, (AAndExpression) semanticObject); 
				return; 
			case AlphaPackage.AARG_REDUCE_EXPRESSION:
				sequence_AArgReduceExpression(context, (AArgReduceExpression) semanticObject); 
				return; 
			case AlphaPackage.AAUTO_RESTRICT_EXPRESSION:
				sequence_AAutoRestrictExpression(context, (AAutoRestrictExpression) semanticObject); 
				return; 
			case AlphaPackage.ABINARY_POLY_OBJ_EXPRESSION:
				sequence_APolyhedralObjectExpression(context, (ABinaryPolyObjExpression) semanticObject); 
				return; 
			case AlphaPackage.ABOOLEAN_EXPRESSION:
				sequence_ABooleanExpression(context, (ABooleanExpression) semanticObject); 
				return; 
			case AlphaPackage.ACASE_EXPRESSION:
				sequence_ACaseExpression(context, (ACaseExpression) semanticObject); 
				return; 
			case AlphaPackage.ACONSTANT:
				sequence_AConstant(context, (AConstant) semanticObject); 
				return; 
			case AlphaPackage.ACONV_EXPRESSION:
				sequence_AConvExpression(context, (AConvExpression) semanticObject); 
				return; 
			case AlphaPackage.ADECLARED_OBJECT:
				sequence_ADeclaredObject(context, (ADeclaredObject) semanticObject); 
				return; 
			case AlphaPackage.ADEPENDENCE_EXPRESSION:
				sequence_ADependenceExpression(context, (ADependenceExpression) semanticObject); 
				return; 
			case AlphaPackage.ADEPENDENCE_IN_ARRAY_NOTATION:
				sequence_ADependenceInArrayNotation(context, (ADependenceInArrayNotation) semanticObject); 
				return; 
			case AlphaPackage.AEQUATION:
				sequence_AEquation(context, (AEquation) semanticObject); 
				return; 
			case AlphaPackage.AEXTERNAL_FUNCTION:
				sequence_AExternalFunction(context, (AExternalFunction) semanticObject); 
				return; 
			case AlphaPackage.AEXTERNAL_FUNCTION_CALL:
				sequence_AExternalFunctionCall(context, (AExternalFunctionCall) semanticObject); 
				return; 
			case AlphaPackage.AFUNCTION:
				sequence_AFunction(context, (AFunction) semanticObject); 
				return; 
			case AlphaPackage.AFUNCTION_IN_ARRAY_NOTATION:
				sequence_AFunctionInArrayNotation(context, (AFunctionInArrayNotation) semanticObject); 
				return; 
			case AlphaPackage.AFUZZY_VARIABLE_DECLARATION:
				sequence_AFuzzyVariableDeclaration(context, (AFuzzyVariableDeclaration) semanticObject); 
				return; 
			case AlphaPackage.AISL_BASIC_RELATION:
				sequence_AISLBasicRelation(context, (AISLBasicRelation) semanticObject); 
				return; 
			case AlphaPackage.AISL_BASIC_SET:
				sequence_AISLBasicSet(context, (AISLBasicSet) semanticObject); 
				return; 
			case AlphaPackage.AISL_RELATION:
				sequence_AISLRelation(context, (AISLRelation) semanticObject); 
				return; 
			case AlphaPackage.AISL_SET:
				sequence_AISLSet(context, (AISLSet) semanticObject); 
				return; 
			case AlphaPackage.AIF_EXPRESSION:
				sequence_AIfExpression(context, (AIfExpression) semanticObject); 
				return; 
			case AlphaPackage.AIMPORT:
				sequence_AImport(context, (AImport) semanticObject); 
				return; 
			case AlphaPackage.AINDEX_AFFINE_EXPRESSION_LIST:
				sequence_AIndexAffineExpressionList(context, (AIndexAffineExpressionList) semanticObject); 
				return; 
			case AlphaPackage.AINDEX_EXPRESSION:
				sequence_AIndexExpression(context, (AIndexExpression) semanticObject); 
				return; 
			case AlphaPackage.AINDEX_EXPRESSION_IN_ARRAY_NOTATION:
				sequence_AIndexExpressionInArrayNotation(context, (AIndexExpressionInArrayNotation) semanticObject); 
				return; 
			case AlphaPackage.AINTEGER_EXPRESSION:
				sequence_AIntegerExpression(context, (AIntegerExpression) semanticObject); 
				return; 
			case AlphaPackage.AMIN_MAX_EXPRESSION:
				sequence_AMinMaxExpression(context, (AMinMaxExpression) semanticObject); 
				return; 
			case AlphaPackage.AMULTI_ARG_ARITHMETIC_EXPRESSION:
				sequence_AMultiArgArithmeticExpression(context, (AMultiArgArithmeticExpression) semanticObject); 
				return; 
			case AlphaPackage.AMULTI_ARG_LOGICAL_EXPRESSION:
				sequence_AMultiArgLogicalExpression(context, (AMultiArgLogicalExpression) semanticObject); 
				return; 
			case AlphaPackage.AMULTIPLICATIVE_EXPRESSION:
				sequence_AMultiplicativeExpression(context, (AMultiplicativeExpression) semanticObject); 
				return; 
			case AlphaPackage.ANEGATE_EXPRESSION:
				sequence_ANegateExpression(context, (ANegateExpression) semanticObject); 
				return; 
			case AlphaPackage.ANOT_EXPRESSION:
				sequence_ANotExpression(context, (ANotExpression) semanticObject); 
				return; 
			case AlphaPackage.AOR_EXPRESSION:
				sequence_AOrExpression(context, (AOrExpression) semanticObject); 
				return; 
			case AlphaPackage.APACKAGE_DECLARATION:
				sequence_APackageDeclaration(context, (APackageDeclaration) semanticObject); 
				return; 
			case AlphaPackage.APOLYHEDRAL_OBJECT_EXPRESSION:
				sequence_AUnaryPolyObjExpression(context, (APolyhedralObjectExpression) semanticObject); 
				return; 
			case AlphaPackage.AREAL_EXPRESSION:
				sequence_ARealExpression(context, (ARealExpression) semanticObject); 
				return; 
			case AlphaPackage.ARECTANGULAR_DOMAIN:
				sequence_ARectangularDomain(context, (ARectangularDomain) semanticObject); 
				return; 
			case AlphaPackage.AREDUCE_EXPRESSION:
				sequence_AReduceExpression(context, (AReduceExpression) semanticObject); 
				return; 
			case AlphaPackage.AREDUCTION_OPERATOR:
				sequence_AReductionOperator(context, (AReductionOperator) semanticObject); 
				return; 
			case AlphaPackage.ARELATIONAL_EXPRESSION:
				sequence_ARelationalExpression(context, (ARelationalExpression) semanticObject); 
				return; 
			case AlphaPackage.ARESTRICT_EXPRESSION:
				sequence_ARestrictExpression(context, (ARestrictExpression) semanticObject); 
				return; 
			case AlphaPackage.ASELECT_DEPENDENCE_EXPRESSION:
				sequence_ASelectDependenceExpression(context, (ASelectDependenceExpression) semanticObject); 
				return; 
			case AlphaPackage.ASTART:
				sequence_AStart(context, (AStart) semanticObject); 
				return; 
			case AlphaPackage.AUSE_EQUATION:
				sequence_AUseEquation(context, (AUseEquation) semanticObject); 
				return; 
			case AlphaPackage.AVARIABLE:
				sequence_AVariable(context, (AVariable) semanticObject); 
				return; 
			case AlphaPackage.AVARIABLE_DECLARATION:
				sequence_AVariableDeclaration(context, (AVariableDeclaration) semanticObject); 
				return; 
			case AlphaPackage.AVARIABLE_DOMAIN:
				sequence_AVariableDomain(context, (AVariableDomain) semanticObject); 
				return; 
			case AlphaPackage.AVARIABLE_EXPRESSION:
				sequence_AVariableExpression(context, (AVariableExpression) semanticObject); 
				return; 
			case AlphaPackage.AVARIABLE_LIST:
				sequence_AVariableList(context, (AVariableList) semanticObject); 
				return; 
			case AlphaPackage.POLYHEDRAL_OBJECT:
				sequence_PolyhedralObject(context, (PolyhedralObject) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AAdditiveExpression
	 *     AAlphabetsTerminalExpression returns AAdditiveExpression
	 *     AParanthesizedAlphabetsExpression returns AAdditiveExpression
	 *     AOrExpression returns AAdditiveExpression
	 *     AOrExpression.AOrExpression_1_0 returns AAdditiveExpression
	 *     AAndExpression returns AAdditiveExpression
	 *     AAndExpression.AAndExpression_1_0 returns AAdditiveExpression
	 *     ARelationalExpression returns AAdditiveExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AAdditiveExpression
	 *     AAdditiveExpression returns AAdditiveExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AAdditiveExpression
	 *     AMultiplicativeExpression returns AAdditiveExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AAdditiveExpression
	 *     AMinMaxExpression returns AAdditiveExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AAdditiveExpression
	 *     AUnaryOrTerminalExpression returns AAdditiveExpression
	 *
	 * Constraint:
	 *     (left=AAdditiveExpression_AAdditiveExpression_1_0 (op=OP_PLUS | op=OP_MINUS) right=AMultiplicativeExpression)
	 */
	protected void sequence_AAdditiveExpression(ISerializationContext context, AAdditiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns AAffineSystem
	 *     AAffineSystem returns AAffineSystem
	 *
	 * Constraint:
	 *     (
	 *         name=SystemName 
	 *         parameters=AParamDomain 
	 *         polyObjects+=PolyhedralObject* 
	 *         inputDeclarations+=AVariableDeclaration* 
	 *         outputDeclarations+=AVariableDeclaration* 
	 *         localvarDeclarations+=AVariableDeclaration* 
	 *         fuzzyVariables+=AFuzzyVariableDeclaration* 
	 *         (whileDomain=APolyhedralObjectExpression while?='while' testExpression=AAlphaExpression)? 
	 *         useEquations+=AUseEquation* 
	 *         equations+=AEquation*
	 *     )
	 */
	protected void sequence_AAffineSystem(ISerializationContext context, AAffineSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AAndExpression
	 *     AAlphabetsTerminalExpression returns AAndExpression
	 *     AParanthesizedAlphabetsExpression returns AAndExpression
	 *     AOrExpression returns AAndExpression
	 *     AOrExpression.AOrExpression_1_0 returns AAndExpression
	 *     AAndExpression returns AAndExpression
	 *     AAndExpression.AAndExpression_1_0 returns AAndExpression
	 *     ARelationalExpression returns AAndExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AAndExpression
	 *     AAdditiveExpression returns AAndExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AAndExpression
	 *     AMultiplicativeExpression returns AAndExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AAndExpression
	 *     AMinMaxExpression returns AAndExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AAndExpression
	 *     AUnaryOrTerminalExpression returns AAndExpression
	 *
	 * Constraint:
	 *     (left=AAndExpression_AAndExpression_1_0 (operator=OP_AND | operator=OP_NAND) right=ARelationalExpression)
	 */
	protected void sequence_AAndExpression(ISerializationContext context, AAndExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AArgReduceExpression
	 *     AAlphabetsTerminalExpression returns AArgReduceExpression
	 *     AParanthesizedAlphabetsExpression returns AArgReduceExpression
	 *     AOrExpression returns AArgReduceExpression
	 *     AOrExpression.AOrExpression_1_0 returns AArgReduceExpression
	 *     AAndExpression returns AArgReduceExpression
	 *     AAndExpression.AAndExpression_1_0 returns AArgReduceExpression
	 *     ARelationalExpression returns AArgReduceExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AArgReduceExpression
	 *     AAdditiveExpression returns AArgReduceExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AArgReduceExpression
	 *     AMultiplicativeExpression returns AArgReduceExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AArgReduceExpression
	 *     AMinMaxExpression returns AArgReduceExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AArgReduceExpression
	 *     AUnaryOrTerminalExpression returns AArgReduceExpression
	 *     AArgReduceExpression returns AArgReduceExpression
	 *
	 * Constraint:
	 *     (op=AReductionOperator (projection=AFunction | projection=AFunctionInArrayNotation) expr=AAlphaExpression)
	 */
	protected void sequence_AArgReduceExpression(ISerializationContext context, AArgReduceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AAutoRestrictExpression
	 *     AAlphabetsTerminalExpression returns AAutoRestrictExpression
	 *     AParanthesizedAlphabetsExpression returns AAutoRestrictExpression
	 *     AOrExpression returns AAutoRestrictExpression
	 *     AOrExpression.AOrExpression_1_0 returns AAutoRestrictExpression
	 *     AAndExpression returns AAutoRestrictExpression
	 *     AAndExpression.AAndExpression_1_0 returns AAutoRestrictExpression
	 *     ARelationalExpression returns AAutoRestrictExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AAutoRestrictExpression
	 *     AAdditiveExpression returns AAutoRestrictExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AAutoRestrictExpression
	 *     AMultiplicativeExpression returns AAutoRestrictExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AAutoRestrictExpression
	 *     AMinMaxExpression returns AAutoRestrictExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AAutoRestrictExpression
	 *     AUnaryOrTerminalExpression returns AAutoRestrictExpression
	 *     AAutoRestrictExpression returns AAutoRestrictExpression
	 *
	 * Constraint:
	 *     expr=AAlphaExpression
	 */
	protected void sequence_AAutoRestrictExpression(ISerializationContext context, AAutoRestrictExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AAUTO_RESTRICT_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AAUTO_RESTRICT_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAAutoRestrictExpressionAccess().getExprAAlphaExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ABooleanExpression
	 *     AAlphabetsTerminalExpression returns ABooleanExpression
	 *     AParanthesizedAlphabetsExpression returns ABooleanExpression
	 *     AOrExpression returns ABooleanExpression
	 *     AOrExpression.AOrExpression_1_0 returns ABooleanExpression
	 *     AAndExpression returns ABooleanExpression
	 *     AAndExpression.AAndExpression_1_0 returns ABooleanExpression
	 *     ARelationalExpression returns ABooleanExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ABooleanExpression
	 *     AAdditiveExpression returns ABooleanExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ABooleanExpression
	 *     AMultiplicativeExpression returns ABooleanExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ABooleanExpression
	 *     AMinMaxExpression returns ABooleanExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ABooleanExpression
	 *     AUnaryOrTerminalExpression returns ABooleanExpression
	 *     AConstantExpression returns ABooleanExpression
	 *     ABooleanExpression returns ABooleanExpression
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_ABooleanExpression(ISerializationContext context, ABooleanExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ABOOLEAN_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ABOOLEAN_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getABooleanExpressionAccess().getValueBOOLEANTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ACaseExpression
	 *     AAlphabetsTerminalExpression returns ACaseExpression
	 *     AParanthesizedAlphabetsExpression returns ACaseExpression
	 *     AOrExpression returns ACaseExpression
	 *     AOrExpression.AOrExpression_1_0 returns ACaseExpression
	 *     AAndExpression returns ACaseExpression
	 *     AAndExpression.AAndExpression_1_0 returns ACaseExpression
	 *     ARelationalExpression returns ACaseExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ACaseExpression
	 *     AAdditiveExpression returns ACaseExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ACaseExpression
	 *     AMultiplicativeExpression returns ACaseExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ACaseExpression
	 *     AMinMaxExpression returns ACaseExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ACaseExpression
	 *     AUnaryOrTerminalExpression returns ACaseExpression
	 *     ACaseExpression returns ACaseExpression
	 *
	 * Constraint:
	 *     (name=ID? exprs+=AAlphaExpression+)
	 */
	protected void sequence_ACaseExpression(ISerializationContext context, ACaseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns AConstant
	 *     AConstantDeclaration returns AConstant
	 *     AConstant returns AConstant
	 *
	 * Constraint:
	 *     (name=ID value=INT)
	 */
	protected void sequence_AConstant(ISerializationContext context, AConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ACONSTANT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ACONSTANT__NAME));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ACONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ACONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAConstantAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAConstantAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AConvExpression
	 *     AAlphabetsTerminalExpression returns AConvExpression
	 *     AParanthesizedAlphabetsExpression returns AConvExpression
	 *     AOrExpression returns AConvExpression
	 *     AOrExpression.AOrExpression_1_0 returns AConvExpression
	 *     AAndExpression returns AConvExpression
	 *     AAndExpression.AAndExpression_1_0 returns AConvExpression
	 *     ARelationalExpression returns AConvExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AConvExpression
	 *     AAdditiveExpression returns AConvExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AConvExpression
	 *     AMultiplicativeExpression returns AConvExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AConvExpression
	 *     AMinMaxExpression returns AConvExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AConvExpression
	 *     AUnaryOrTerminalExpression returns AConvExpression
	 *     AConvExpression returns AConvExpression
	 *
	 * Constraint:
	 *     (domain=APolyhedralObjectExpression kernel=AAlphaExpression data=AAlphaExpression)
	 */
	protected void sequence_AConvExpression(ISerializationContext context, AConvExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ACONV_EXPRESSION__DOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ACONV_EXPRESSION__DOMAIN));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ACONV_EXPRESSION__KERNEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ACONV_EXPRESSION__KERNEL));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ACONV_EXPRESSION__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ACONV_EXPRESSION__DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAConvExpressionAccess().getDomainAPolyhedralObjectExpressionParserRuleCall_2_0(), semanticObject.getDomain());
		feeder.accept(grammarAccess.getAConvExpressionAccess().getKernelAAlphaExpressionParserRuleCall_4_0(), semanticObject.getKernel());
		feeder.accept(grammarAccess.getAConvExpressionAccess().getDataAAlphaExpressionParserRuleCall_6_0(), semanticObject.getData());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     APolyhedralObjectExpression returns ADeclaredObject
	 *     APolyhedralObjectExpression.ABinaryPolyObjExpression_1_0 returns ADeclaredObject
	 *     AUnaryOrTerminalPolyObjExpression returns ADeclaredObject
	 *     APolyObjTerminal returns ADeclaredObject
	 *     ADeclaredObject returns ADeclaredObject
	 *     APolyObjectInRestrict returns ADeclaredObject
	 *
	 * Constraint:
	 *     object=[PolyhedralObject|ID]
	 */
	protected void sequence_ADeclaredObject(ISerializationContext context, ADeclaredObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ADECLARED_OBJECT__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ADECLARED_OBJECT__OBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getADeclaredObjectAccess().getObjectPolyhedralObjectIDTerminalRuleCall_0_1(), semanticObject.eGet(AlphaPackage.Literals.ADECLARED_OBJECT__OBJECT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ADependenceExpression
	 *     AAlphabetsTerminalExpression returns ADependenceExpression
	 *     AParanthesizedAlphabetsExpression returns ADependenceExpression
	 *     AOrExpression returns ADependenceExpression
	 *     AOrExpression.AOrExpression_1_0 returns ADependenceExpression
	 *     AAndExpression returns ADependenceExpression
	 *     AAndExpression.AAndExpression_1_0 returns ADependenceExpression
	 *     ARelationalExpression returns ADependenceExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ADependenceExpression
	 *     AAdditiveExpression returns ADependenceExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ADependenceExpression
	 *     AMultiplicativeExpression returns ADependenceExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ADependenceExpression
	 *     AMinMaxExpression returns ADependenceExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ADependenceExpression
	 *     AUnaryOrTerminalExpression returns ADependenceExpression
	 *     ADependenceExpression returns ADependenceExpression
	 *
	 * Constraint:
	 *     (function=AFunction expr=AAlphabetsTerminalExpression)
	 */
	protected void sequence_ADependenceExpression(ISerializationContext context, ADependenceExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ADEPENDENCE_EXPRESSION__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ADEPENDENCE_EXPRESSION__FUNCTION));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ADEPENDENCE_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ADEPENDENCE_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getADependenceExpressionAccess().getFunctionAFunctionParserRuleCall_0_0(), semanticObject.getFunction());
		feeder.accept(grammarAccess.getADependenceExpressionAccess().getExprAAlphabetsTerminalExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ADependenceInArrayNotation
	 *     AAlphabetsTerminalExpression returns ADependenceInArrayNotation
	 *     AParanthesizedAlphabetsExpression returns ADependenceInArrayNotation
	 *     AOrExpression returns ADependenceInArrayNotation
	 *     AOrExpression.AOrExpression_1_0 returns ADependenceInArrayNotation
	 *     AAndExpression returns ADependenceInArrayNotation
	 *     AAndExpression.AAndExpression_1_0 returns ADependenceInArrayNotation
	 *     ARelationalExpression returns ADependenceInArrayNotation
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ADependenceInArrayNotation
	 *     AAdditiveExpression returns ADependenceInArrayNotation
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ADependenceInArrayNotation
	 *     AMultiplicativeExpression returns ADependenceInArrayNotation
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ADependenceInArrayNotation
	 *     AMinMaxExpression returns ADependenceInArrayNotation
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ADependenceInArrayNotation
	 *     AUnaryOrTerminalExpression returns ADependenceInArrayNotation
	 *     ADependenceInArrayNotation returns ADependenceInArrayNotation
	 *
	 * Constraint:
	 *     (var=[AVariable|ID] dep=AIndexAffineExpressionList)
	 */
	protected void sequence_ADependenceInArrayNotation(ISerializationContext context, ADependenceInArrayNotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ADEPENDENCE_IN_ARRAY_NOTATION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ADEPENDENCE_IN_ARRAY_NOTATION__VAR));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ADEPENDENCE_IN_ARRAY_NOTATION__DEP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ADEPENDENCE_IN_ARRAY_NOTATION__DEP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getADependenceInArrayNotationAccess().getVarAVariableIDTerminalRuleCall_0_0_1(), semanticObject.eGet(AlphaPackage.Literals.ADEPENDENCE_IN_ARRAY_NOTATION__VAR, false));
		feeder.accept(grammarAccess.getADependenceInArrayNotationAccess().getDepAIndexAffineExpressionListParserRuleCall_2_0(), semanticObject.getDep());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AEquation returns AEquation
	 *
	 * Constraint:
	 *     (var=[AVariable|ID] indexes=AIndexList? expr=AAlphaExpression)
	 */
	protected void sequence_AEquation(ISerializationContext context, AEquation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AExternalFunctionCall
	 *     AAlphabetsTerminalExpression returns AExternalFunctionCall
	 *     AParanthesizedAlphabetsExpression returns AExternalFunctionCall
	 *     AOrExpression returns AExternalFunctionCall
	 *     AOrExpression.AOrExpression_1_0 returns AExternalFunctionCall
	 *     AAndExpression returns AExternalFunctionCall
	 *     AAndExpression.AAndExpression_1_0 returns AExternalFunctionCall
	 *     ARelationalExpression returns AExternalFunctionCall
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AExternalFunctionCall
	 *     AAdditiveExpression returns AExternalFunctionCall
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AExternalFunctionCall
	 *     AMultiplicativeExpression returns AExternalFunctionCall
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AExternalFunctionCall
	 *     AMinMaxExpression returns AExternalFunctionCall
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AExternalFunctionCall
	 *     AUnaryOrTerminalExpression returns AExternalFunctionCall
	 *     AMultiArgExpression returns AExternalFunctionCall
	 *     AExternalFunctionCall returns AExternalFunctionCall
	 *
	 * Constraint:
	 *     (func=[AExternalFunction|ID] (exprs+=AAlphaExpression exprs+=AAlphaExpression*)?)
	 */
	protected void sequence_AExternalFunctionCall(ISerializationContext context, AExternalFunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns AExternalFunction
	 *     AExternalFunctionDeclaration returns AExternalFunction
	 *     AExternalFunction returns AExternalFunction
	 *
	 * Constraint:
	 *     (name=ID inputCardinarity=INT)
	 */
	protected void sequence_AExternalFunction(ISerializationContext context, AExternalFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AEXTERNAL_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AEXTERNAL_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AEXTERNAL_FUNCTION__INPUT_CARDINARITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AEXTERNAL_FUNCTION__INPUT_CARDINARITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAExternalFunctionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAExternalFunctionAccess().getInputCardinarityINTTerminalRuleCall_2_0(), semanticObject.getInputCardinarity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AFunctionInArrayNotation returns AFunctionInArrayNotation
	 *
	 * Constraint:
	 *     newIds=AIndexAffineExpressionList
	 */
	protected void sequence_AFunctionInArrayNotation(ISerializationContext context, AFunctionInArrayNotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AFUNCTION_IN_ARRAY_NOTATION__NEW_IDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AFUNCTION_IN_ARRAY_NOTATION__NEW_IDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAFunctionInArrayNotationAccess().getNewIdsAIndexAffineExpressionListParserRuleCall_1_0(), semanticObject.getNewIds());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AFunction returns AFunction
	 *
	 * Constraint:
	 *     (indexes=AIndexList func=AIndexAffineExpressionList)
	 */
	protected void sequence_AFunction(ISerializationContext context, AFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AFUNCTION__INDEXES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AFUNCTION__INDEXES));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AFUNCTION__FUNC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AFUNCTION__FUNC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAFunctionAccess().getIndexesAIndexListParserRuleCall_1_0(), semanticObject.getIndexes());
		feeder.accept(grammarAccess.getAFunctionAccess().getFuncAIndexAffineExpressionListParserRuleCall_3_0(), semanticObject.getFunc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AFuzzyVariableDeclaration returns AFuzzyVariableDeclaration
	 *
	 * Constraint:
	 *     (varList=AVariableList relation=APolyhedralObjectExpression)
	 */
	protected void sequence_AFuzzyVariableDeclaration(ISerializationContext context, AFuzzyVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AFUZZY_VARIABLE_DECLARATION__VAR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AFUZZY_VARIABLE_DECLARATION__VAR_LIST));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AFUZZY_VARIABLE_DECLARATION__RELATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AFUZZY_VARIABLE_DECLARATION__RELATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAFuzzyVariableDeclarationAccess().getVarListAVariableListParserRuleCall_0_0(), semanticObject.getVarList());
		feeder.accept(grammarAccess.getAFuzzyVariableDeclarationAccess().getRelationAPolyhedralObjectExpressionParserRuleCall_2_0(), semanticObject.getRelation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AISLBasicRelation returns AISLBasicRelation
	 *
	 * Constraint:
	 *     (inDims=AIndexList outDims=AIndexList constraintStr=ISLString)
	 */
	protected void sequence_AISLBasicRelation(ISerializationContext context, AISLBasicRelation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AISL_BASIC_RELATION__IN_DIMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AISL_BASIC_RELATION__IN_DIMS));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AISL_BASIC_RELATION__OUT_DIMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AISL_BASIC_RELATION__OUT_DIMS));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AISL_BASIC_RELATION__CONSTRAINT_STR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AISL_BASIC_RELATION__CONSTRAINT_STR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAISLBasicRelationAccess().getInDimsAIndexListParserRuleCall_1_0(), semanticObject.getInDims());
		feeder.accept(grammarAccess.getAISLBasicRelationAccess().getOutDimsAIndexListParserRuleCall_5_0(), semanticObject.getOutDims());
		feeder.accept(grammarAccess.getAISLBasicRelationAccess().getConstraintStrISLStringParserRuleCall_8_0(), semanticObject.getConstraintStr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AISLBasicSet returns AISLBasicSet
	 *
	 * Constraint:
	 *     (dims=AIndexList? constraintString=ISLString)
	 */
	protected void sequence_AISLBasicSet(ISerializationContext context, AISLBasicSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     APolyhedralObjectExpression returns AISLRelation
	 *     APolyhedralObjectExpression.ABinaryPolyObjExpression_1_0 returns AISLRelation
	 *     AUnaryOrTerminalPolyObjExpression returns AISLRelation
	 *     APolyObjTerminal returns AISLRelation
	 *     AISLRelation returns AISLRelation
	 *     APolyObjectInRestrict returns AISLRelation
	 *
	 * Constraint:
	 *     (relations+=AISLBasicRelation relations+=AISLBasicRelation*)
	 */
	protected void sequence_AISLRelation(ISerializationContext context, AISLRelation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     APolyhedralObjectExpression returns AISLSet
	 *     APolyhedralObjectExpression.ABinaryPolyObjExpression_1_0 returns AISLSet
	 *     AUnaryOrTerminalPolyObjExpression returns AISLSet
	 *     APolyObjTerminal returns AISLSet
	 *     AISLSet returns AISLSet
	 *     APolyObjectInRestrict returns AISLSet
	 *
	 * Constraint:
	 *     (sets+=AISLBasicSet relations+=AISLBasicSet*)
	 */
	protected void sequence_AISLSet(ISerializationContext context, AISLSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AIfExpression
	 *     AAlphabetsTerminalExpression returns AIfExpression
	 *     AParanthesizedAlphabetsExpression returns AIfExpression
	 *     AOrExpression returns AIfExpression
	 *     AOrExpression.AOrExpression_1_0 returns AIfExpression
	 *     AAndExpression returns AIfExpression
	 *     AAndExpression.AAndExpression_1_0 returns AIfExpression
	 *     ARelationalExpression returns AIfExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AIfExpression
	 *     AAdditiveExpression returns AIfExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AIfExpression
	 *     AMultiplicativeExpression returns AIfExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AIfExpression
	 *     AMinMaxExpression returns AIfExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AIfExpression
	 *     AUnaryOrTerminalExpression returns AIfExpression
	 *     AIfExpression returns AIfExpression
	 *
	 * Constraint:
	 *     (cond=AAlphaExpression then=AAlphaExpression else=AAlphaExpression)
	 */
	protected void sequence_AIfExpression(ISerializationContext context, AIfExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AIF_EXPRESSION__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AIF_EXPRESSION__COND));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AIF_EXPRESSION__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AIF_EXPRESSION__THEN));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AIF_EXPRESSION__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AIF_EXPRESSION__ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAIfExpressionAccess().getCondAAlphaExpressionParserRuleCall_1_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getAIfExpressionAccess().getThenAAlphaExpressionParserRuleCall_3_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getAIfExpressionAccess().getElseAAlphaExpressionParserRuleCall_5_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns AImport
	 *     AImport returns AImport
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_AImport(ISerializationContext context, AImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AIMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AIMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AIndexAffineExpressionList returns AIndexAffineExpressionList
	 *
	 * Constraint:
	 *     (exprs+=IndexAffineExpression exprs+=IndexAffineExpression*)?
	 */
	protected void sequence_AIndexAffineExpressionList(ISerializationContext context, AIndexAffineExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AIndexExpressionInArrayNotation
	 *     AAlphabetsTerminalExpression returns AIndexExpressionInArrayNotation
	 *     AParanthesizedAlphabetsExpression returns AIndexExpressionInArrayNotation
	 *     AOrExpression returns AIndexExpressionInArrayNotation
	 *     AOrExpression.AOrExpression_1_0 returns AIndexExpressionInArrayNotation
	 *     AAndExpression returns AIndexExpressionInArrayNotation
	 *     AAndExpression.AAndExpression_1_0 returns AIndexExpressionInArrayNotation
	 *     ARelationalExpression returns AIndexExpressionInArrayNotation
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AIndexExpressionInArrayNotation
	 *     AAdditiveExpression returns AIndexExpressionInArrayNotation
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AIndexExpressionInArrayNotation
	 *     AMultiplicativeExpression returns AIndexExpressionInArrayNotation
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AIndexExpressionInArrayNotation
	 *     AMinMaxExpression returns AIndexExpressionInArrayNotation
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AIndexExpressionInArrayNotation
	 *     AUnaryOrTerminalExpression returns AIndexExpressionInArrayNotation
	 *     AIndexExpressionInArrayNotation returns AIndexExpressionInArrayNotation
	 *
	 * Constraint:
	 *     func=IndexAffineExpressionTerminal
	 */
	protected void sequence_AIndexExpressionInArrayNotation(ISerializationContext context, AIndexExpressionInArrayNotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AINDEX_EXPRESSION_IN_ARRAY_NOTATION__FUNC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AINDEX_EXPRESSION_IN_ARRAY_NOTATION__FUNC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAIndexExpressionInArrayNotationAccess().getFuncIndexAffineExpressionTerminalParserRuleCall_1_0(), semanticObject.getFunc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AIndexExpression
	 *     AAlphabetsTerminalExpression returns AIndexExpression
	 *     AParanthesizedAlphabetsExpression returns AIndexExpression
	 *     AOrExpression returns AIndexExpression
	 *     AOrExpression.AOrExpression_1_0 returns AIndexExpression
	 *     AAndExpression returns AIndexExpression
	 *     AAndExpression.AAndExpression_1_0 returns AIndexExpression
	 *     ARelationalExpression returns AIndexExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AIndexExpression
	 *     AAdditiveExpression returns AIndexExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AIndexExpression
	 *     AMultiplicativeExpression returns AIndexExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AIndexExpression
	 *     AMinMaxExpression returns AIndexExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AIndexExpression
	 *     AUnaryOrTerminalExpression returns AIndexExpression
	 *     AIndexExpression returns AIndexExpression
	 *
	 * Constraint:
	 *     (indexes=AIndexList func=IndexAffineExpressionTerminal)
	 */
	protected void sequence_AIndexExpression(ISerializationContext context, AIndexExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AINDEX_EXPRESSION__INDEXES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AINDEX_EXPRESSION__INDEXES));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AINDEX_EXPRESSION__FUNC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AINDEX_EXPRESSION__FUNC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAIndexExpressionAccess().getIndexesAIndexListParserRuleCall_1_0(), semanticObject.getIndexes());
		feeder.accept(grammarAccess.getAIndexExpressionAccess().getFuncIndexAffineExpressionTerminalParserRuleCall_3_0(), semanticObject.getFunc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AIntegerExpression
	 *     AAlphabetsTerminalExpression returns AIntegerExpression
	 *     AParanthesizedAlphabetsExpression returns AIntegerExpression
	 *     AOrExpression returns AIntegerExpression
	 *     AOrExpression.AOrExpression_1_0 returns AIntegerExpression
	 *     AAndExpression returns AIntegerExpression
	 *     AAndExpression.AAndExpression_1_0 returns AIntegerExpression
	 *     ARelationalExpression returns AIntegerExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AIntegerExpression
	 *     AAdditiveExpression returns AIntegerExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AIntegerExpression
	 *     AMultiplicativeExpression returns AIntegerExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AIntegerExpression
	 *     AMinMaxExpression returns AIntegerExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AIntegerExpression
	 *     AUnaryOrTerminalExpression returns AIntegerExpression
	 *     AConstantExpression returns AIntegerExpression
	 *     AIntegerExpression returns AIntegerExpression
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_AIntegerExpression(ISerializationContext context, AIntegerExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AINTEGER_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AINTEGER_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAIntegerExpressionAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AMinMaxExpression
	 *     AAlphabetsTerminalExpression returns AMinMaxExpression
	 *     AParanthesizedAlphabetsExpression returns AMinMaxExpression
	 *     AOrExpression returns AMinMaxExpression
	 *     AOrExpression.AOrExpression_1_0 returns AMinMaxExpression
	 *     AAndExpression returns AMinMaxExpression
	 *     AAndExpression.AAndExpression_1_0 returns AMinMaxExpression
	 *     ARelationalExpression returns AMinMaxExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AMinMaxExpression
	 *     AAdditiveExpression returns AMinMaxExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AMinMaxExpression
	 *     AMultiplicativeExpression returns AMinMaxExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AMinMaxExpression
	 *     AMinMaxExpression returns AMinMaxExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AMinMaxExpression
	 *     AUnaryOrTerminalExpression returns AMinMaxExpression
	 *
	 * Constraint:
	 *     (left=AMinMaxExpression_AMinMaxExpression_1_0 (op=OP_MIN | op=OP_MAX) right=AUnaryOrTerminalExpression)
	 */
	protected void sequence_AMinMaxExpression(ISerializationContext context, AMinMaxExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AMultiArgArithmeticExpression
	 *     AAlphabetsTerminalExpression returns AMultiArgArithmeticExpression
	 *     AParanthesizedAlphabetsExpression returns AMultiArgArithmeticExpression
	 *     AOrExpression returns AMultiArgArithmeticExpression
	 *     AOrExpression.AOrExpression_1_0 returns AMultiArgArithmeticExpression
	 *     AAndExpression returns AMultiArgArithmeticExpression
	 *     AAndExpression.AAndExpression_1_0 returns AMultiArgArithmeticExpression
	 *     ARelationalExpression returns AMultiArgArithmeticExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AMultiArgArithmeticExpression
	 *     AAdditiveExpression returns AMultiArgArithmeticExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AMultiArgArithmeticExpression
	 *     AMultiplicativeExpression returns AMultiArgArithmeticExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AMultiArgArithmeticExpression
	 *     AMinMaxExpression returns AMultiArgArithmeticExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AMultiArgArithmeticExpression
	 *     AUnaryOrTerminalExpression returns AMultiArgArithmeticExpression
	 *     AMultiArgExpression returns AMultiArgArithmeticExpression
	 *     AMultiArgArithmeticExpression returns AMultiArgArithmeticExpression
	 *
	 * Constraint:
	 *     (op=ARITHMETIC_REDUCTION_OP exprs+=AAlphaExpression exprs+=AAlphaExpression+)
	 */
	protected void sequence_AMultiArgArithmeticExpression(ISerializationContext context, AMultiArgArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AMultiArgLogicalExpression
	 *     AAlphabetsTerminalExpression returns AMultiArgLogicalExpression
	 *     AParanthesizedAlphabetsExpression returns AMultiArgLogicalExpression
	 *     AOrExpression returns AMultiArgLogicalExpression
	 *     AOrExpression.AOrExpression_1_0 returns AMultiArgLogicalExpression
	 *     AAndExpression returns AMultiArgLogicalExpression
	 *     AAndExpression.AAndExpression_1_0 returns AMultiArgLogicalExpression
	 *     ARelationalExpression returns AMultiArgLogicalExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AMultiArgLogicalExpression
	 *     AAdditiveExpression returns AMultiArgLogicalExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AMultiArgLogicalExpression
	 *     AMultiplicativeExpression returns AMultiArgLogicalExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AMultiArgLogicalExpression
	 *     AMinMaxExpression returns AMultiArgLogicalExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AMultiArgLogicalExpression
	 *     AUnaryOrTerminalExpression returns AMultiArgLogicalExpression
	 *     AMultiArgExpression returns AMultiArgLogicalExpression
	 *     AMultiArgLogicalExpression returns AMultiArgLogicalExpression
	 *
	 * Constraint:
	 *     (op=LOGICAL_REDUCTION_OP exprs+=AAlphaExpression exprs+=AAlphaExpression+)
	 */
	protected void sequence_AMultiArgLogicalExpression(ISerializationContext context, AMultiArgLogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AMultiplicativeExpression
	 *     AAlphabetsTerminalExpression returns AMultiplicativeExpression
	 *     AParanthesizedAlphabetsExpression returns AMultiplicativeExpression
	 *     AOrExpression returns AMultiplicativeExpression
	 *     AOrExpression.AOrExpression_1_0 returns AMultiplicativeExpression
	 *     AAndExpression returns AMultiplicativeExpression
	 *     AAndExpression.AAndExpression_1_0 returns AMultiplicativeExpression
	 *     ARelationalExpression returns AMultiplicativeExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AMultiplicativeExpression
	 *     AAdditiveExpression returns AMultiplicativeExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AMultiplicativeExpression
	 *     AMultiplicativeExpression returns AMultiplicativeExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AMultiplicativeExpression
	 *     AMinMaxExpression returns AMultiplicativeExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AMultiplicativeExpression
	 *     AUnaryOrTerminalExpression returns AMultiplicativeExpression
	 *
	 * Constraint:
	 *     (left=AMultiplicativeExpression_AMultiplicativeExpression_1_0 (op=OP_MUL | op=OP_DIV) right=AMinMaxExpression)
	 */
	protected void sequence_AMultiplicativeExpression(ISerializationContext context, AMultiplicativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ANegateExpression
	 *     AAlphabetsTerminalExpression returns ANegateExpression
	 *     AParanthesizedAlphabetsExpression returns ANegateExpression
	 *     AOrExpression returns ANegateExpression
	 *     AOrExpression.AOrExpression_1_0 returns ANegateExpression
	 *     AAndExpression returns ANegateExpression
	 *     AAndExpression.AAndExpression_1_0 returns ANegateExpression
	 *     ARelationalExpression returns ANegateExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ANegateExpression
	 *     AAdditiveExpression returns ANegateExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ANegateExpression
	 *     AMultiplicativeExpression returns ANegateExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ANegateExpression
	 *     AMinMaxExpression returns ANegateExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ANegateExpression
	 *     AUnaryOrTerminalExpression returns ANegateExpression
	 *     AUnaryExpression returns ANegateExpression
	 *     ANegateExpression returns ANegateExpression
	 *
	 * Constraint:
	 *     (op=OP_MINUS expr=AAlphabetsTerminalExpression)
	 */
	protected void sequence_ANegateExpression(ISerializationContext context, ANegateExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ANEGATE_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ANEGATE_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ANEGATE_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ANEGATE_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getANegateExpressionAccess().getOpOP_MINUSTerminalRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getANegateExpressionAccess().getExprAAlphabetsTerminalExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ANotExpression
	 *     AAlphabetsTerminalExpression returns ANotExpression
	 *     AParanthesizedAlphabetsExpression returns ANotExpression
	 *     AOrExpression returns ANotExpression
	 *     AOrExpression.AOrExpression_1_0 returns ANotExpression
	 *     AAndExpression returns ANotExpression
	 *     AAndExpression.AAndExpression_1_0 returns ANotExpression
	 *     ARelationalExpression returns ANotExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ANotExpression
	 *     AAdditiveExpression returns ANotExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ANotExpression
	 *     AMultiplicativeExpression returns ANotExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ANotExpression
	 *     AMinMaxExpression returns ANotExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ANotExpression
	 *     AUnaryOrTerminalExpression returns ANotExpression
	 *     AUnaryExpression returns ANotExpression
	 *     ANotExpression returns ANotExpression
	 *
	 * Constraint:
	 *     (op='not' expr=AAlphabetsTerminalExpression)
	 */
	protected void sequence_ANotExpression(ISerializationContext context, ANotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ANOT_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ANOT_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ANOT_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ANOT_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getANotExpressionAccess().getOpNotKeyword_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getANotExpressionAccess().getExprAAlphabetsTerminalExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AOrExpression
	 *     AAlphabetsTerminalExpression returns AOrExpression
	 *     AParanthesizedAlphabetsExpression returns AOrExpression
	 *     AOrExpression returns AOrExpression
	 *     AOrExpression.AOrExpression_1_0 returns AOrExpression
	 *     AAndExpression returns AOrExpression
	 *     AAndExpression.AAndExpression_1_0 returns AOrExpression
	 *     ARelationalExpression returns AOrExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AOrExpression
	 *     AAdditiveExpression returns AOrExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AOrExpression
	 *     AMultiplicativeExpression returns AOrExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AOrExpression
	 *     AMinMaxExpression returns AOrExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AOrExpression
	 *     AUnaryOrTerminalExpression returns AOrExpression
	 *
	 * Constraint:
	 *     (left=AOrExpression_AOrExpression_1_0 (operator=OP_OR | operator=OP_XOR) right=AAndExpression)
	 */
	protected void sequence_AOrExpression(ISerializationContext context, AOrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns APackageDeclaration
	 *     APackageDeclaration returns APackageDeclaration
	 *
	 * Constraint:
	 *     (name=QualifiedName elements+=AbstractElement*)
	 */
	protected void sequence_APackageDeclaration(ISerializationContext context, APackageDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     APolyhedralObjectExpression returns ABinaryPolyObjExpression
	 *     APolyhedralObjectExpression.ABinaryPolyObjExpression_1_0 returns ABinaryPolyObjExpression
	 *     AUnaryOrTerminalPolyObjExpression returns ABinaryPolyObjExpression
	 *     APolyObjTerminal returns ABinaryPolyObjExpression
	 *     APolyObjectInRestrict returns ABinaryPolyObjExpression
	 *
	 * Constraint:
	 *     (
	 *         left=APolyhedralObjectExpression_ABinaryPolyObjExpression_1_0 
	 *         (
	 *             operator='cross' | 
	 *             operator=OP_PLUS | 
	 *             operator=OP_MINUS | 
	 *             operator=OP_MUL | 
	 *             operator='@' | 
	 *             operator='->-' | 
	 *             operator='->*'
	 *         ) 
	 *         right=AUnaryOrTerminalPolyObjExpression
	 *     )
	 */
	protected void sequence_APolyhedralObjectExpression(ISerializationContext context, ABinaryPolyObjExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ARealExpression
	 *     AAlphabetsTerminalExpression returns ARealExpression
	 *     AParanthesizedAlphabetsExpression returns ARealExpression
	 *     AOrExpression returns ARealExpression
	 *     AOrExpression.AOrExpression_1_0 returns ARealExpression
	 *     AAndExpression returns ARealExpression
	 *     AAndExpression.AAndExpression_1_0 returns ARealExpression
	 *     ARelationalExpression returns ARealExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ARealExpression
	 *     AAdditiveExpression returns ARealExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ARealExpression
	 *     AMultiplicativeExpression returns ARealExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ARealExpression
	 *     AMinMaxExpression returns ARealExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ARealExpression
	 *     AUnaryOrTerminalExpression returns ARealExpression
	 *     AConstantExpression returns ARealExpression
	 *     ARealExpression returns ARealExpression
	 *
	 * Constraint:
	 *     value=REAL
	 */
	protected void sequence_ARealExpression(ISerializationContext context, ARealExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AREAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AREAL_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getARealExpressionAccess().getValueREALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     APolyhedralObjectExpression returns ARectangularDomain
	 *     APolyhedralObjectExpression.ABinaryPolyObjExpression_1_0 returns ARectangularDomain
	 *     AUnaryOrTerminalPolyObjExpression returns ARectangularDomain
	 *     APolyObjTerminal returns ARectangularDomain
	 *     ARectangularDomain returns ARectangularDomain
	 *     APolyObjectInRestrict returns ARectangularDomain
	 *
	 * Constraint:
	 *     (dimensions+=AIndexList names+=AIndexList?)
	 */
	protected void sequence_ARectangularDomain(ISerializationContext context, ARectangularDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AReduceExpression
	 *     AAlphabetsTerminalExpression returns AReduceExpression
	 *     AParanthesizedAlphabetsExpression returns AReduceExpression
	 *     AOrExpression returns AReduceExpression
	 *     AOrExpression.AOrExpression_1_0 returns AReduceExpression
	 *     AAndExpression returns AReduceExpression
	 *     AAndExpression.AAndExpression_1_0 returns AReduceExpression
	 *     ARelationalExpression returns AReduceExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AReduceExpression
	 *     AAdditiveExpression returns AReduceExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AReduceExpression
	 *     AMultiplicativeExpression returns AReduceExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AReduceExpression
	 *     AMinMaxExpression returns AReduceExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AReduceExpression
	 *     AUnaryOrTerminalExpression returns AReduceExpression
	 *     AReduceExpression returns AReduceExpression
	 *
	 * Constraint:
	 *     (op=AReductionOperator (projection=AFunction | projection=AFunctionInArrayNotation) expr=AAlphaExpression)
	 */
	protected void sequence_AReduceExpression(ISerializationContext context, AReduceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AReductionOperator returns AReductionOperator
	 *
	 * Constraint:
	 *     (op=[AExternalFunction|ID] | builtin=REDUCTION_OP)
	 */
	protected void sequence_AReductionOperator(ISerializationContext context, AReductionOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ARelationalExpression
	 *     AAlphabetsTerminalExpression returns ARelationalExpression
	 *     AParanthesizedAlphabetsExpression returns ARelationalExpression
	 *     AOrExpression returns ARelationalExpression
	 *     AOrExpression.AOrExpression_1_0 returns ARelationalExpression
	 *     AAndExpression returns ARelationalExpression
	 *     AAndExpression.AAndExpression_1_0 returns ARelationalExpression
	 *     ARelationalExpression returns ARelationalExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ARelationalExpression
	 *     AAdditiveExpression returns ARelationalExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ARelationalExpression
	 *     AMultiplicativeExpression returns ARelationalExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ARelationalExpression
	 *     AMinMaxExpression returns ARelationalExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ARelationalExpression
	 *     AUnaryOrTerminalExpression returns ARelationalExpression
	 *
	 * Constraint:
	 *     (left=ARelationalExpression_ARelationalExpression_1_0 operator=RELATIONAL_OP right=AAdditiveExpression)
	 */
	protected void sequence_ARelationalExpression(ISerializationContext context, ARelationalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ARELATIONAL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ARELATIONAL_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ARELATIONAL_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ARELATIONAL_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ARELATIONAL_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ARELATIONAL_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getARelationalExpressionAccess().getARelationalExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getARelationalExpressionAccess().getOperatorRELATIONAL_OPParserRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getARelationalExpressionAccess().getRightAAdditiveExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ARestrictExpression
	 *     AAlphabetsTerminalExpression returns ARestrictExpression
	 *     AParanthesizedAlphabetsExpression returns ARestrictExpression
	 *     AOrExpression returns ARestrictExpression
	 *     AOrExpression.AOrExpression_1_0 returns ARestrictExpression
	 *     AAndExpression returns ARestrictExpression
	 *     AAndExpression.AAndExpression_1_0 returns ARestrictExpression
	 *     ARelationalExpression returns ARestrictExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ARestrictExpression
	 *     AAdditiveExpression returns ARestrictExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ARestrictExpression
	 *     AMultiplicativeExpression returns ARestrictExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ARestrictExpression
	 *     AMinMaxExpression returns ARestrictExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ARestrictExpression
	 *     AUnaryOrTerminalExpression returns ARestrictExpression
	 *     ARestrictExpression returns ARestrictExpression
	 *
	 * Constraint:
	 *     (domain=APolyObjectInRestrict expr=AAlphaExpression)
	 */
	protected void sequence_ARestrictExpression(ISerializationContext context, ARestrictExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ARESTRICT_EXPRESSION__DOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ARESTRICT_EXPRESSION__DOMAIN));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ARESTRICT_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ARESTRICT_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getARestrictExpressionAccess().getDomainAPolyObjectInRestrictParserRuleCall_0_0(), semanticObject.getDomain());
		feeder.accept(grammarAccess.getARestrictExpressionAccess().getExprAAlphaExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ASelectDependenceExpression
	 *     AAlphabetsTerminalExpression returns ASelectDependenceExpression
	 *     AParanthesizedAlphabetsExpression returns ASelectDependenceExpression
	 *     AOrExpression returns ASelectDependenceExpression
	 *     AOrExpression.AOrExpression_1_0 returns ASelectDependenceExpression
	 *     AAndExpression returns ASelectDependenceExpression
	 *     AAndExpression.AAndExpression_1_0 returns ASelectDependenceExpression
	 *     ARelationalExpression returns ASelectDependenceExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ASelectDependenceExpression
	 *     AAdditiveExpression returns ASelectDependenceExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ASelectDependenceExpression
	 *     AMultiplicativeExpression returns ASelectDependenceExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ASelectDependenceExpression
	 *     AMinMaxExpression returns ASelectDependenceExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ASelectDependenceExpression
	 *     AUnaryOrTerminalExpression returns ASelectDependenceExpression
	 *     ASelectDependenceExpression returns ASelectDependenceExpression
	 *
	 * Constraint:
	 *     (relation=APolyhedralObjectExpression expr=AAlphabetsTerminalExpression)
	 */
	protected void sequence_ASelectDependenceExpression(ISerializationContext context, ASelectDependenceExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ASELECT_DEPENDENCE_EXPRESSION__RELATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ASELECT_DEPENDENCE_EXPRESSION__RELATION));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ASELECT_DEPENDENCE_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ASELECT_DEPENDENCE_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getASelectDependenceExpressionAccess().getRelationAPolyhedralObjectExpressionParserRuleCall_1_0(), semanticObject.getRelation());
		feeder.accept(grammarAccess.getASelectDependenceExpressionAccess().getExprAAlphabetsTerminalExpressionParserRuleCall_3_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AStart returns AStart
	 *
	 * Constraint:
	 *     elements+=AbstractElement+
	 */
	protected void sequence_AStart(ISerializationContext context, AStart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     APolyhedralObjectExpression returns APolyhedralObjectExpression
	 *     APolyhedralObjectExpression.ABinaryPolyObjExpression_1_0 returns APolyhedralObjectExpression
	 *     AUnaryOrTerminalPolyObjExpression returns APolyhedralObjectExpression
	 *     APolyObjTerminal returns APolyhedralObjectExpression
	 *     AUnaryPolyObjExpression returns APolyhedralObjectExpression
	 *     APolyObjectInRestrict returns APolyhedralObjectExpression
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             op='domain' | 
	 *             op='range' | 
	 *             op='complement' | 
	 *             op='poly-hull' | 
	 *             op='affine-hull' | 
	 *             op='reverse'
	 *         ) 
	 *         expr=APolyObjTerminal
	 *     )
	 */
	protected void sequence_AUnaryPolyObjExpression(ISerializationContext context, APolyhedralObjectExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AUseEquation returns AUseEquation
	 *
	 * Constraint:
	 *     (
	 *         (instantiationDomain=APolyhedralObjectExpression subsystemDims=AIndexList?)? 
	 *         (outputExprs+=AAlphaExpression outputExprs+=AAlphaExpression*)? 
	 *         system=[AAffineSystem|ID] 
	 *         callParams=AIndexAffineExpressionList 
	 *         (inputExprs+=AAlphaExpression inputExprs+=AAlphaExpression*)?
	 *     )
	 */
	protected void sequence_AUseEquation(ISerializationContext context, AUseEquation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AVariableDeclaration returns AVariableDeclaration
	 *
	 * Constraint:
	 *     (varList=AVariableList domain=APolyhedralObjectExpression?)
	 */
	protected void sequence_AVariableDeclaration(ISerializationContext context, AVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     APolyhedralObjectExpression returns AVariableDomain
	 *     APolyhedralObjectExpression.ABinaryPolyObjExpression_1_0 returns AVariableDomain
	 *     AUnaryOrTerminalPolyObjExpression returns AVariableDomain
	 *     APolyObjTerminal returns AVariableDomain
	 *     AVariableDomain returns AVariableDomain
	 *     APolyObjectInRestrict returns AVariableDomain
	 *
	 * Constraint:
	 *     var=[AVariable|ID]
	 */
	protected void sequence_AVariableDomain(ISerializationContext context, AVariableDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AVARIABLE_DOMAIN__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AVARIABLE_DOMAIN__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAVariableDomainAccess().getVarAVariableIDTerminalRuleCall_1_0_1(), semanticObject.eGet(AlphaPackage.Literals.AVARIABLE_DOMAIN__VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AVariableExpression
	 *     AAlphabetsTerminalExpression returns AVariableExpression
	 *     AParanthesizedAlphabetsExpression returns AVariableExpression
	 *     AOrExpression returns AVariableExpression
	 *     AOrExpression.AOrExpression_1_0 returns AVariableExpression
	 *     AAndExpression returns AVariableExpression
	 *     AAndExpression.AAndExpression_1_0 returns AVariableExpression
	 *     ARelationalExpression returns AVariableExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AVariableExpression
	 *     AAdditiveExpression returns AVariableExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AVariableExpression
	 *     AMultiplicativeExpression returns AVariableExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AVariableExpression
	 *     AMinMaxExpression returns AVariableExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AVariableExpression
	 *     AUnaryOrTerminalExpression returns AVariableExpression
	 *     AVariableExpression returns AVariableExpression
	 *
	 * Constraint:
	 *     var=[AVariable|ID]
	 */
	protected void sequence_AVariableExpression(ISerializationContext context, AVariableExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AVARIABLE_EXPRESSION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AVARIABLE_EXPRESSION__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAVariableExpressionAccess().getVarAVariableIDTerminalRuleCall_0_1(), semanticObject.eGet(AlphaPackage.Literals.AVARIABLE_EXPRESSION__VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AVariableList returns AVariableList
	 *
	 * Constraint:
	 *     (vars+=AVariable vars+=AVariable*)
	 */
	protected void sequence_AVariableList(ISerializationContext context, AVariableList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AVariable returns AVariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_AVariable(ISerializationContext context, AVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AVARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AVARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PolyhedralObject returns PolyhedralObject
	 *
	 * Constraint:
	 *     (name=ID object=APolyhedralObjectExpression)
	 */
	protected void sequence_PolyhedralObject(ISerializationContext context, PolyhedralObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.POLYHEDRAL_OBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.POLYHEDRAL_OBJECT__NAME));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.POLYHEDRAL_OBJECT__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.POLYHEDRAL_OBJECT__OBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPolyhedralObjectAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPolyhedralObjectAccess().getObjectAPolyhedralObjectExpressionParserRuleCall_2_0(), semanticObject.getObject());
		feeder.finish();
	}
	
	
}
