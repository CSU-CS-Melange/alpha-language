/*
 * generated by Xtext 2.12.0
 */
package alpha.serializer;

import alpha.alpha.AAdditiveExpression;
import alpha.alpha.AAffineSystem;
import alpha.alpha.AAndExpression;
import alpha.alpha.AArgReduceExpression;
import alpha.alpha.ABooleanExpression;
import alpha.alpha.ACaseExpression;
import alpha.alpha.ADependenceExpression;
import alpha.alpha.ADependenceInArrayNotation;
import alpha.alpha.ADomain;
import alpha.alpha.ADomainProduct;
import alpha.alpha.AEquation;
import alpha.alpha.AExternalFunction;
import alpha.alpha.AExternalFunctionCall;
import alpha.alpha.AFunction;
import alpha.alpha.AFunctionInArrayNotation;
import alpha.alpha.AFuzzyVariableDeclaration;
import alpha.alpha.AISLDomain;
import alpha.alpha.AIfExpression;
import alpha.alpha.AImport;
import alpha.alpha.AIndexAffineExpressionList;
import alpha.alpha.AIndexDimension;
import alpha.alpha.AIndexExpression;
import alpha.alpha.AIndexList;
import alpha.alpha.AIntegerExpression;
import alpha.alpha.AMinMaxExpression;
import alpha.alpha.AMultiArgArithmeticExpression;
import alpha.alpha.AMultiArgLogicalExpression;
import alpha.alpha.AMultiplicativeExpression;
import alpha.alpha.ANegateExpression;
import alpha.alpha.ANotExpression;
import alpha.alpha.AOrExpression;
import alpha.alpha.APackageDeclaration;
import alpha.alpha.AParamDomain;
import alpha.alpha.ARealExpression;
import alpha.alpha.AReduceExpression;
import alpha.alpha.AReductionOperator;
import alpha.alpha.ARelation;
import alpha.alpha.ARelationalExpression;
import alpha.alpha.ARestrictExpression;
import alpha.alpha.AStart;
import alpha.alpha.AUseEquation;
import alpha.alpha.AVariable;
import alpha.alpha.AVariableDeclaration;
import alpha.alpha.AVariableDomain;
import alpha.alpha.AVariableExpression;
import alpha.alpha.AVariableList;
import alpha.alpha.AlphaPackage;
import alpha.services.AlphaGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AlphaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AlphaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AlphaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AlphaPackage.AADDITIVE_EXPRESSION:
				sequence_AAdditiveExpression(context, (AAdditiveExpression) semanticObject); 
				return; 
			case AlphaPackage.AAFFINE_SYSTEM:
				sequence_AAffineSystem(context, (AAffineSystem) semanticObject); 
				return; 
			case AlphaPackage.AAND_EXPRESSION:
				sequence_AAndExpression(context, (AAndExpression) semanticObject); 
				return; 
			case AlphaPackage.AARG_REDUCE_EXPRESSION:
				sequence_AArgReduceExpression(context, (AArgReduceExpression) semanticObject); 
				return; 
			case AlphaPackage.ABOOLEAN_EXPRESSION:
				sequence_ABooleanExpression(context, (ABooleanExpression) semanticObject); 
				return; 
			case AlphaPackage.ACASE_EXPRESSION:
				sequence_ACaseExpression(context, (ACaseExpression) semanticObject); 
				return; 
			case AlphaPackage.ADEPENDENCE_EXPRESSION:
				sequence_ADependenceExpression(context, (ADependenceExpression) semanticObject); 
				return; 
			case AlphaPackage.ADEPENDENCE_IN_ARRAY_NOTATION:
				sequence_ADependenceInArrayNotation(context, (ADependenceInArrayNotation) semanticObject); 
				return; 
			case AlphaPackage.ADOMAIN:
				sequence_ADomain(context, (ADomain) semanticObject); 
				return; 
			case AlphaPackage.ADOMAIN_PRODUCT:
				sequence_ADomainProduct(context, (ADomainProduct) semanticObject); 
				return; 
			case AlphaPackage.AEQUATION:
				sequence_AEquation(context, (AEquation) semanticObject); 
				return; 
			case AlphaPackage.AEXTERNAL_FUNCTION:
				sequence_AExternalFunction(context, (AExternalFunction) semanticObject); 
				return; 
			case AlphaPackage.AEXTERNAL_FUNCTION_CALL:
				sequence_AExternalFunctionCall(context, (AExternalFunctionCall) semanticObject); 
				return; 
			case AlphaPackage.AFUNCTION:
				sequence_AFunction(context, (AFunction) semanticObject); 
				return; 
			case AlphaPackage.AFUNCTION_IN_ARRAY_NOTATION:
				sequence_AFunctionInArrayNotation(context, (AFunctionInArrayNotation) semanticObject); 
				return; 
			case AlphaPackage.AFUZZY_VARIABLE_DECLARATION:
				sequence_AFuzzyVariableDeclaration(context, (AFuzzyVariableDeclaration) semanticObject); 
				return; 
			case AlphaPackage.AISL_DOMAIN:
				sequence_AISLDomain(context, (AISLDomain) semanticObject); 
				return; 
			case AlphaPackage.AIF_EXPRESSION:
				sequence_AIfExpression(context, (AIfExpression) semanticObject); 
				return; 
			case AlphaPackage.AIMPORT:
				sequence_AImport(context, (AImport) semanticObject); 
				return; 
			case AlphaPackage.AINDEX_AFFINE_EXPRESSION_LIST:
				sequence_AIndexAffineExpressionList(context, (AIndexAffineExpressionList) semanticObject); 
				return; 
			case AlphaPackage.AINDEX_DIMENSION:
				sequence_AIndexDimension(context, (AIndexDimension) semanticObject); 
				return; 
			case AlphaPackage.AINDEX_EXPRESSION:
				sequence_AIndexExpression(context, (AIndexExpression) semanticObject); 
				return; 
			case AlphaPackage.AINDEX_LIST:
				sequence_AIndexList(context, (AIndexList) semanticObject); 
				return; 
			case AlphaPackage.AINTEGER_EXPRESSION:
				sequence_AIntegerExpression(context, (AIntegerExpression) semanticObject); 
				return; 
			case AlphaPackage.AMIN_MAX_EXPRESSION:
				sequence_AMinMaxExpression(context, (AMinMaxExpression) semanticObject); 
				return; 
			case AlphaPackage.AMULTI_ARG_ARITHMETIC_EXPRESSION:
				sequence_AMultiArgArithmeticExpression(context, (AMultiArgArithmeticExpression) semanticObject); 
				return; 
			case AlphaPackage.AMULTI_ARG_LOGICAL_EXPRESSION:
				sequence_AMultiArgLogicalExpression(context, (AMultiArgLogicalExpression) semanticObject); 
				return; 
			case AlphaPackage.AMULTIPLICATIVE_EXPRESSION:
				sequence_AMultiplicativeExpression(context, (AMultiplicativeExpression) semanticObject); 
				return; 
			case AlphaPackage.ANEGATE_EXPRESSION:
				sequence_ANegateExpression(context, (ANegateExpression) semanticObject); 
				return; 
			case AlphaPackage.ANOT_EXPRESSION:
				sequence_ANotExpression(context, (ANotExpression) semanticObject); 
				return; 
			case AlphaPackage.AOR_EXPRESSION:
				sequence_AOrExpression(context, (AOrExpression) semanticObject); 
				return; 
			case AlphaPackage.APACKAGE_DECLARATION:
				sequence_APackageDeclaration(context, (APackageDeclaration) semanticObject); 
				return; 
			case AlphaPackage.APARAM_DOMAIN:
				sequence_AParamDomain(context, (AParamDomain) semanticObject); 
				return; 
			case AlphaPackage.AREAL_EXPRESSION:
				sequence_ARealExpression(context, (ARealExpression) semanticObject); 
				return; 
			case AlphaPackage.AREDUCE_EXPRESSION:
				sequence_AReduceExpression(context, (AReduceExpression) semanticObject); 
				return; 
			case AlphaPackage.AREDUCTION_OPERATOR:
				sequence_AReductionOperator(context, (AReductionOperator) semanticObject); 
				return; 
			case AlphaPackage.ARELATION:
				sequence_ARelation(context, (ARelation) semanticObject); 
				return; 
			case AlphaPackage.ARELATIONAL_EXPRESSION:
				sequence_ARelationalExpression(context, (ARelationalExpression) semanticObject); 
				return; 
			case AlphaPackage.ARESTRICT_EXPRESSION:
				sequence_ARestrictExpression(context, (ARestrictExpression) semanticObject); 
				return; 
			case AlphaPackage.ASTART:
				sequence_AStart(context, (AStart) semanticObject); 
				return; 
			case AlphaPackage.AUSE_EQUATION:
				sequence_AUseEquation(context, (AUseEquation) semanticObject); 
				return; 
			case AlphaPackage.AVARIABLE:
				sequence_AVariable(context, (AVariable) semanticObject); 
				return; 
			case AlphaPackage.AVARIABLE_DECLARATION:
				sequence_AVariableDeclaration(context, (AVariableDeclaration) semanticObject); 
				return; 
			case AlphaPackage.AVARIABLE_DOMAIN:
				sequence_AVariableDomain(context, (AVariableDomain) semanticObject); 
				return; 
			case AlphaPackage.AVARIABLE_EXPRESSION:
				sequence_AVariableExpression(context, (AVariableExpression) semanticObject); 
				return; 
			case AlphaPackage.AVARIABLE_LIST:
				sequence_AVariableList(context, (AVariableList) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AAdditiveExpression
	 *     AAlphabetsTerminalExpression returns AAdditiveExpression
	 *     AParanthesizedAlphabetsExpression returns AAdditiveExpression
	 *     AOrExpression returns AAdditiveExpression
	 *     AOrExpression.AOrExpression_1_0 returns AAdditiveExpression
	 *     AAndExpression returns AAdditiveExpression
	 *     AAndExpression.AAndExpression_1_0 returns AAdditiveExpression
	 *     ARelationalExpression returns AAdditiveExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AAdditiveExpression
	 *     AAdditiveExpression returns AAdditiveExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AAdditiveExpression
	 *     AMultiplicativeExpression returns AAdditiveExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AAdditiveExpression
	 *     AMinMaxExpression returns AAdditiveExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AAdditiveExpression
	 *     AUnaryOrTerminalExpression returns AAdditiveExpression
	 *
	 * Constraint:
	 *     (left=AAdditiveExpression_AAdditiveExpression_1_0 (op=OP_PLUS | op=OP_MINUS) right=AMultiplicativeExpression)
	 */
	protected void sequence_AAdditiveExpression(ISerializationContext context, AAdditiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns AAffineSystem
	 *     AAffineSystem returns AAffineSystem
	 *
	 * Constraint:
	 *     (
	 *         name=SystemName 
	 *         parameters=AParamDomain 
	 *         inputDeclarations+=AVariableDeclaration* 
	 *         outputDeclarations+=AVariableDeclaration* 
	 *         localvarDeclarations+=AVariableDeclaration* 
	 *         fuzzyVariables+=AFuzzyVariableDeclaration* 
	 *         useEquations+=AUseEquation* 
	 *         equations+=AEquation*
	 *     )
	 */
	protected void sequence_AAffineSystem(ISerializationContext context, AAffineSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AAndExpression
	 *     AAlphabetsTerminalExpression returns AAndExpression
	 *     AParanthesizedAlphabetsExpression returns AAndExpression
	 *     AOrExpression returns AAndExpression
	 *     AOrExpression.AOrExpression_1_0 returns AAndExpression
	 *     AAndExpression returns AAndExpression
	 *     AAndExpression.AAndExpression_1_0 returns AAndExpression
	 *     ARelationalExpression returns AAndExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AAndExpression
	 *     AAdditiveExpression returns AAndExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AAndExpression
	 *     AMultiplicativeExpression returns AAndExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AAndExpression
	 *     AMinMaxExpression returns AAndExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AAndExpression
	 *     AUnaryOrTerminalExpression returns AAndExpression
	 *
	 * Constraint:
	 *     (left=AAndExpression_AAndExpression_1_0 (operator=OP_AND | operator=OP_NAND) right=ARelationalExpression)
	 */
	protected void sequence_AAndExpression(ISerializationContext context, AAndExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AArgReduceExpression
	 *     AAlphabetsTerminalExpression returns AArgReduceExpression
	 *     AParanthesizedAlphabetsExpression returns AArgReduceExpression
	 *     AOrExpression returns AArgReduceExpression
	 *     AOrExpression.AOrExpression_1_0 returns AArgReduceExpression
	 *     AAndExpression returns AArgReduceExpression
	 *     AAndExpression.AAndExpression_1_0 returns AArgReduceExpression
	 *     ARelationalExpression returns AArgReduceExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AArgReduceExpression
	 *     AAdditiveExpression returns AArgReduceExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AArgReduceExpression
	 *     AMultiplicativeExpression returns AArgReduceExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AArgReduceExpression
	 *     AMinMaxExpression returns AArgReduceExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AArgReduceExpression
	 *     AUnaryOrTerminalExpression returns AArgReduceExpression
	 *     AArgReduceExpression returns AArgReduceExpression
	 *
	 * Constraint:
	 *     (op=AReductionOperator (projection=AFunction | projection=AFunctionInArrayNotation) expr=AAlphaExpression)
	 */
	protected void sequence_AArgReduceExpression(ISerializationContext context, AArgReduceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ABooleanExpression
	 *     AAlphabetsTerminalExpression returns ABooleanExpression
	 *     AParanthesizedAlphabetsExpression returns ABooleanExpression
	 *     AOrExpression returns ABooleanExpression
	 *     AOrExpression.AOrExpression_1_0 returns ABooleanExpression
	 *     AAndExpression returns ABooleanExpression
	 *     AAndExpression.AAndExpression_1_0 returns ABooleanExpression
	 *     ARelationalExpression returns ABooleanExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ABooleanExpression
	 *     AAdditiveExpression returns ABooleanExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ABooleanExpression
	 *     AMultiplicativeExpression returns ABooleanExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ABooleanExpression
	 *     AMinMaxExpression returns ABooleanExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ABooleanExpression
	 *     AUnaryOrTerminalExpression returns ABooleanExpression
	 *     AConstantExpression returns ABooleanExpression
	 *     ABooleanExpression returns ABooleanExpression
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_ABooleanExpression(ISerializationContext context, ABooleanExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ABOOLEAN_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ABOOLEAN_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getABooleanExpressionAccess().getValueBOOLEANTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ACaseExpression
	 *     AAlphabetsTerminalExpression returns ACaseExpression
	 *     AParanthesizedAlphabetsExpression returns ACaseExpression
	 *     AOrExpression returns ACaseExpression
	 *     AOrExpression.AOrExpression_1_0 returns ACaseExpression
	 *     AAndExpression returns ACaseExpression
	 *     AAndExpression.AAndExpression_1_0 returns ACaseExpression
	 *     ARelationalExpression returns ACaseExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ACaseExpression
	 *     AAdditiveExpression returns ACaseExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ACaseExpression
	 *     AMultiplicativeExpression returns ACaseExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ACaseExpression
	 *     AMinMaxExpression returns ACaseExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ACaseExpression
	 *     AUnaryOrTerminalExpression returns ACaseExpression
	 *     ACaseExpression returns ACaseExpression
	 *
	 * Constraint:
	 *     (name=ID? exprs+=AAlphaExpression+)
	 */
	protected void sequence_ACaseExpression(ISerializationContext context, ACaseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ADependenceExpression
	 *     AAlphabetsTerminalExpression returns ADependenceExpression
	 *     AParanthesizedAlphabetsExpression returns ADependenceExpression
	 *     AOrExpression returns ADependenceExpression
	 *     AOrExpression.AOrExpression_1_0 returns ADependenceExpression
	 *     AAndExpression returns ADependenceExpression
	 *     AAndExpression.AAndExpression_1_0 returns ADependenceExpression
	 *     ARelationalExpression returns ADependenceExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ADependenceExpression
	 *     AAdditiveExpression returns ADependenceExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ADependenceExpression
	 *     AMultiplicativeExpression returns ADependenceExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ADependenceExpression
	 *     AMinMaxExpression returns ADependenceExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ADependenceExpression
	 *     AUnaryOrTerminalExpression returns ADependenceExpression
	 *     ADependenceExpression returns ADependenceExpression
	 *
	 * Constraint:
	 *     (func=AFunction expr=AAlphabetsTerminalExpression)
	 */
	protected void sequence_ADependenceExpression(ISerializationContext context, ADependenceExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ADEPENDENCE_EXPRESSION__FUNC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ADEPENDENCE_EXPRESSION__FUNC));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ADEPENDENCE_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ADEPENDENCE_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getADependenceExpressionAccess().getFuncAFunctionParserRuleCall_0_0(), semanticObject.getFunc());
		feeder.accept(grammarAccess.getADependenceExpressionAccess().getExprAAlphabetsTerminalExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ADependenceInArrayNotation
	 *     AAlphabetsTerminalExpression returns ADependenceInArrayNotation
	 *     AParanthesizedAlphabetsExpression returns ADependenceInArrayNotation
	 *     AOrExpression returns ADependenceInArrayNotation
	 *     AOrExpression.AOrExpression_1_0 returns ADependenceInArrayNotation
	 *     AAndExpression returns ADependenceInArrayNotation
	 *     AAndExpression.AAndExpression_1_0 returns ADependenceInArrayNotation
	 *     ARelationalExpression returns ADependenceInArrayNotation
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ADependenceInArrayNotation
	 *     AAdditiveExpression returns ADependenceInArrayNotation
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ADependenceInArrayNotation
	 *     AMultiplicativeExpression returns ADependenceInArrayNotation
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ADependenceInArrayNotation
	 *     AMinMaxExpression returns ADependenceInArrayNotation
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ADependenceInArrayNotation
	 *     AUnaryOrTerminalExpression returns ADependenceInArrayNotation
	 *     ADependenceInArrayNotation returns ADependenceInArrayNotation
	 *
	 * Constraint:
	 *     (var=[AVariable|ID] dep=AIndexAffineExpressionList)
	 */
	protected void sequence_ADependenceInArrayNotation(ISerializationContext context, ADependenceInArrayNotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ADEPENDENCE_IN_ARRAY_NOTATION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ADEPENDENCE_IN_ARRAY_NOTATION__VAR));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ADEPENDENCE_IN_ARRAY_NOTATION__DEP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ADEPENDENCE_IN_ARRAY_NOTATION__DEP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getADependenceInArrayNotationAccess().getVarAVariableIDTerminalRuleCall_0_0_1(), semanticObject.eGet(AlphaPackage.Literals.ADEPENDENCE_IN_ARRAY_NOTATION__VAR, false));
		feeder.accept(grammarAccess.getADependenceInArrayNotationAccess().getDepAIndexAffineExpressionListParserRuleCall_2_0(), semanticObject.getDep());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ADomainExpression returns ADomainProduct
	 *     ADomainProduct returns ADomainProduct
	 *
	 * Constraint:
	 *     (extension=ADomainTerminal base=ADomainExpression)
	 */
	protected void sequence_ADomainProduct(ISerializationContext context, ADomainProduct semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ADOMAIN_PRODUCT__EXTENSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ADOMAIN_PRODUCT__EXTENSION));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ADOMAIN_PRODUCT__BASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ADOMAIN_PRODUCT__BASE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getADomainProductAccess().getExtensionADomainTerminalParserRuleCall_0_0(), semanticObject.getExtension());
		feeder.accept(grammarAccess.getADomainProductAccess().getBaseADomainExpressionParserRuleCall_2_0(), semanticObject.getBase());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ADomain returns ADomain
	 *
	 * Constraint:
	 *     ((dims=AIndexList? constraintString=ISLString) | var=[AVariable|ID])
	 */
	protected void sequence_ADomain(ISerializationContext context, ADomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AEquation returns AEquation
	 *
	 * Constraint:
	 *     (var=[AVariable|ID] indexes=AIndexList? expr=AAlphaExpression)
	 */
	protected void sequence_AEquation(ISerializationContext context, AEquation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AExternalFunctionCall
	 *     AAlphabetsTerminalExpression returns AExternalFunctionCall
	 *     AParanthesizedAlphabetsExpression returns AExternalFunctionCall
	 *     AOrExpression returns AExternalFunctionCall
	 *     AOrExpression.AOrExpression_1_0 returns AExternalFunctionCall
	 *     AAndExpression returns AExternalFunctionCall
	 *     AAndExpression.AAndExpression_1_0 returns AExternalFunctionCall
	 *     ARelationalExpression returns AExternalFunctionCall
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AExternalFunctionCall
	 *     AAdditiveExpression returns AExternalFunctionCall
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AExternalFunctionCall
	 *     AMultiplicativeExpression returns AExternalFunctionCall
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AExternalFunctionCall
	 *     AMinMaxExpression returns AExternalFunctionCall
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AExternalFunctionCall
	 *     AUnaryOrTerminalExpression returns AExternalFunctionCall
	 *     AMultiArgExpression returns AExternalFunctionCall
	 *     AExternalFunctionCall returns AExternalFunctionCall
	 *
	 * Constraint:
	 *     (func=[AExternalFunction|ID] (exprs+=AAlphaExpression exprs+=AAlphaExpression*)?)
	 */
	protected void sequence_AExternalFunctionCall(ISerializationContext context, AExternalFunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns AExternalFunction
	 *     AExternalFunctionDeclaration returns AExternalFunction
	 *     AExternalFunction returns AExternalFunction
	 *
	 * Constraint:
	 *     (name=ID inputCardinarity=INT)
	 */
	protected void sequence_AExternalFunction(ISerializationContext context, AExternalFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AEXTERNAL_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AEXTERNAL_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AEXTERNAL_FUNCTION__INPUT_CARDINARITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AEXTERNAL_FUNCTION__INPUT_CARDINARITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAExternalFunctionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAExternalFunctionAccess().getInputCardinarityINTTerminalRuleCall_2_0(), semanticObject.getInputCardinarity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AFunctionInArrayNotation returns AFunctionInArrayNotation
	 *
	 * Constraint:
	 *     newIds=AIndexAffineExpressionList
	 */
	protected void sequence_AFunctionInArrayNotation(ISerializationContext context, AFunctionInArrayNotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AFUNCTION_IN_ARRAY_NOTATION__NEW_IDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AFUNCTION_IN_ARRAY_NOTATION__NEW_IDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAFunctionInArrayNotationAccess().getNewIdsAIndexAffineExpressionListParserRuleCall_1_0(), semanticObject.getNewIds());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AFunction returns AFunction
	 *
	 * Constraint:
	 *     (indexes=AIndexList func=AIndexAffineExpressionList)
	 */
	protected void sequence_AFunction(ISerializationContext context, AFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AFUNCTION__INDEXES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AFUNCTION__INDEXES));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AFUNCTION__FUNC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AFUNCTION__FUNC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAFunctionAccess().getIndexesAIndexListParserRuleCall_1_0(), semanticObject.getIndexes());
		feeder.accept(grammarAccess.getAFunctionAccess().getFuncAIndexAffineExpressionListParserRuleCall_3_0(), semanticObject.getFunc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AFuzzyVariableDeclaration returns AFuzzyVariableDeclaration
	 *
	 * Constraint:
	 *     (varList+=AVariableList relation=ARelation)
	 */
	protected void sequence_AFuzzyVariableDeclaration(ISerializationContext context, AFuzzyVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ADomainExpression returns AISLDomain
	 *     ADomainTerminal returns AISLDomain
	 *     AISLDomain returns AISLDomain
	 *
	 * Constraint:
	 *     (dims=AIndexList? constraintString=ISLString)
	 */
	protected void sequence_AISLDomain(ISerializationContext context, AISLDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AIfExpression
	 *     AAlphabetsTerminalExpression returns AIfExpression
	 *     AParanthesizedAlphabetsExpression returns AIfExpression
	 *     AOrExpression returns AIfExpression
	 *     AOrExpression.AOrExpression_1_0 returns AIfExpression
	 *     AAndExpression returns AIfExpression
	 *     AAndExpression.AAndExpression_1_0 returns AIfExpression
	 *     ARelationalExpression returns AIfExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AIfExpression
	 *     AAdditiveExpression returns AIfExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AIfExpression
	 *     AMultiplicativeExpression returns AIfExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AIfExpression
	 *     AMinMaxExpression returns AIfExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AIfExpression
	 *     AUnaryOrTerminalExpression returns AIfExpression
	 *     AIfExpression returns AIfExpression
	 *
	 * Constraint:
	 *     (cond=AAlphaExpression then=AAlphaExpression else=AAlphaExpression)
	 */
	protected void sequence_AIfExpression(ISerializationContext context, AIfExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AIF_EXPRESSION__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AIF_EXPRESSION__COND));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AIF_EXPRESSION__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AIF_EXPRESSION__THEN));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AIF_EXPRESSION__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AIF_EXPRESSION__ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAIfExpressionAccess().getCondAAlphaExpressionParserRuleCall_1_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getAIfExpressionAccess().getThenAAlphaExpressionParserRuleCall_3_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getAIfExpressionAccess().getElseAAlphaExpressionParserRuleCall_5_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns AImport
	 *     AImport returns AImport
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_AImport(ISerializationContext context, AImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AIMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AIMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AIndexAffineExpressionList returns AIndexAffineExpressionList
	 *
	 * Constraint:
	 *     (exprs+=IndexAffineExpression exprs+=IndexAffineExpression*)?
	 */
	protected void sequence_AIndexAffineExpressionList(ISerializationContext context, AIndexAffineExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AIndexDimension returns AIndexDimension
	 *
	 * Constraint:
	 *     name=IndexName
	 */
	protected void sequence_AIndexDimension(ISerializationContext context, AIndexDimension semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AINDEX_DIMENSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AINDEX_DIMENSION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAIndexDimensionAccess().getNameIndexNameParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AIndexExpression
	 *     AAlphabetsTerminalExpression returns AIndexExpression
	 *     AParanthesizedAlphabetsExpression returns AIndexExpression
	 *     AOrExpression returns AIndexExpression
	 *     AOrExpression.AOrExpression_1_0 returns AIndexExpression
	 *     AAndExpression returns AIndexExpression
	 *     AAndExpression.AAndExpression_1_0 returns AIndexExpression
	 *     ARelationalExpression returns AIndexExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AIndexExpression
	 *     AAdditiveExpression returns AIndexExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AIndexExpression
	 *     AMultiplicativeExpression returns AIndexExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AIndexExpression
	 *     AMinMaxExpression returns AIndexExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AIndexExpression
	 *     AUnaryOrTerminalExpression returns AIndexExpression
	 *     AIndexExpression returns AIndexExpression
	 *
	 * Constraint:
	 *     (func=IndexAffineExpressionTerminal | (indexes=AIndexList func=IndexAffineExpressionTerminal))
	 */
	protected void sequence_AIndexExpression(ISerializationContext context, AIndexExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AIndexList returns AIndexList
	 *
	 * Constraint:
	 *     (ids+=AIndexDimension ids+=AIndexDimension*)?
	 */
	protected void sequence_AIndexList(ISerializationContext context, AIndexList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AIntegerExpression
	 *     AAlphabetsTerminalExpression returns AIntegerExpression
	 *     AParanthesizedAlphabetsExpression returns AIntegerExpression
	 *     AOrExpression returns AIntegerExpression
	 *     AOrExpression.AOrExpression_1_0 returns AIntegerExpression
	 *     AAndExpression returns AIntegerExpression
	 *     AAndExpression.AAndExpression_1_0 returns AIntegerExpression
	 *     ARelationalExpression returns AIntegerExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AIntegerExpression
	 *     AAdditiveExpression returns AIntegerExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AIntegerExpression
	 *     AMultiplicativeExpression returns AIntegerExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AIntegerExpression
	 *     AMinMaxExpression returns AIntegerExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AIntegerExpression
	 *     AUnaryOrTerminalExpression returns AIntegerExpression
	 *     AConstantExpression returns AIntegerExpression
	 *     AIntegerExpression returns AIntegerExpression
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_AIntegerExpression(ISerializationContext context, AIntegerExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AINTEGER_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AINTEGER_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAIntegerExpressionAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AMinMaxExpression
	 *     AAlphabetsTerminalExpression returns AMinMaxExpression
	 *     AParanthesizedAlphabetsExpression returns AMinMaxExpression
	 *     AOrExpression returns AMinMaxExpression
	 *     AOrExpression.AOrExpression_1_0 returns AMinMaxExpression
	 *     AAndExpression returns AMinMaxExpression
	 *     AAndExpression.AAndExpression_1_0 returns AMinMaxExpression
	 *     ARelationalExpression returns AMinMaxExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AMinMaxExpression
	 *     AAdditiveExpression returns AMinMaxExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AMinMaxExpression
	 *     AMultiplicativeExpression returns AMinMaxExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AMinMaxExpression
	 *     AMinMaxExpression returns AMinMaxExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AMinMaxExpression
	 *     AUnaryOrTerminalExpression returns AMinMaxExpression
	 *
	 * Constraint:
	 *     (left=AMinMaxExpression_AMinMaxExpression_1_0 (op=OP_MIN | op=OP_MAX) right=AUnaryOrTerminalExpression)
	 */
	protected void sequence_AMinMaxExpression(ISerializationContext context, AMinMaxExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AMultiArgArithmeticExpression
	 *     AAlphabetsTerminalExpression returns AMultiArgArithmeticExpression
	 *     AParanthesizedAlphabetsExpression returns AMultiArgArithmeticExpression
	 *     AOrExpression returns AMultiArgArithmeticExpression
	 *     AOrExpression.AOrExpression_1_0 returns AMultiArgArithmeticExpression
	 *     AAndExpression returns AMultiArgArithmeticExpression
	 *     AAndExpression.AAndExpression_1_0 returns AMultiArgArithmeticExpression
	 *     ARelationalExpression returns AMultiArgArithmeticExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AMultiArgArithmeticExpression
	 *     AAdditiveExpression returns AMultiArgArithmeticExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AMultiArgArithmeticExpression
	 *     AMultiplicativeExpression returns AMultiArgArithmeticExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AMultiArgArithmeticExpression
	 *     AMinMaxExpression returns AMultiArgArithmeticExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AMultiArgArithmeticExpression
	 *     AUnaryOrTerminalExpression returns AMultiArgArithmeticExpression
	 *     AMultiArgExpression returns AMultiArgArithmeticExpression
	 *     AMultiArgArithmeticExpression returns AMultiArgArithmeticExpression
	 *
	 * Constraint:
	 *     (op=ARITHMETIC_REDUCTION_OP exprs+=AAlphaExpression exprs+=AAlphaExpression+)
	 */
	protected void sequence_AMultiArgArithmeticExpression(ISerializationContext context, AMultiArgArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AMultiArgLogicalExpression
	 *     AAlphabetsTerminalExpression returns AMultiArgLogicalExpression
	 *     AParanthesizedAlphabetsExpression returns AMultiArgLogicalExpression
	 *     AOrExpression returns AMultiArgLogicalExpression
	 *     AOrExpression.AOrExpression_1_0 returns AMultiArgLogicalExpression
	 *     AAndExpression returns AMultiArgLogicalExpression
	 *     AAndExpression.AAndExpression_1_0 returns AMultiArgLogicalExpression
	 *     ARelationalExpression returns AMultiArgLogicalExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AMultiArgLogicalExpression
	 *     AAdditiveExpression returns AMultiArgLogicalExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AMultiArgLogicalExpression
	 *     AMultiplicativeExpression returns AMultiArgLogicalExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AMultiArgLogicalExpression
	 *     AMinMaxExpression returns AMultiArgLogicalExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AMultiArgLogicalExpression
	 *     AUnaryOrTerminalExpression returns AMultiArgLogicalExpression
	 *     AMultiArgExpression returns AMultiArgLogicalExpression
	 *     AMultiArgLogicalExpression returns AMultiArgLogicalExpression
	 *
	 * Constraint:
	 *     (op=LOGICAL_REDUCTION_OP exprs+=AAlphaExpression exprs+=AAlphaExpression+)
	 */
	protected void sequence_AMultiArgLogicalExpression(ISerializationContext context, AMultiArgLogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AMultiplicativeExpression
	 *     AAlphabetsTerminalExpression returns AMultiplicativeExpression
	 *     AParanthesizedAlphabetsExpression returns AMultiplicativeExpression
	 *     AOrExpression returns AMultiplicativeExpression
	 *     AOrExpression.AOrExpression_1_0 returns AMultiplicativeExpression
	 *     AAndExpression returns AMultiplicativeExpression
	 *     AAndExpression.AAndExpression_1_0 returns AMultiplicativeExpression
	 *     ARelationalExpression returns AMultiplicativeExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AMultiplicativeExpression
	 *     AAdditiveExpression returns AMultiplicativeExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AMultiplicativeExpression
	 *     AMultiplicativeExpression returns AMultiplicativeExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AMultiplicativeExpression
	 *     AMinMaxExpression returns AMultiplicativeExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AMultiplicativeExpression
	 *     AUnaryOrTerminalExpression returns AMultiplicativeExpression
	 *
	 * Constraint:
	 *     (left=AMultiplicativeExpression_AMultiplicativeExpression_1_0 (op=OP_MUL | op=OP_DIV) right=AMinMaxExpression)
	 */
	protected void sequence_AMultiplicativeExpression(ISerializationContext context, AMultiplicativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ANegateExpression
	 *     AAlphabetsTerminalExpression returns ANegateExpression
	 *     AParanthesizedAlphabetsExpression returns ANegateExpression
	 *     AOrExpression returns ANegateExpression
	 *     AOrExpression.AOrExpression_1_0 returns ANegateExpression
	 *     AAndExpression returns ANegateExpression
	 *     AAndExpression.AAndExpression_1_0 returns ANegateExpression
	 *     ARelationalExpression returns ANegateExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ANegateExpression
	 *     AAdditiveExpression returns ANegateExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ANegateExpression
	 *     AMultiplicativeExpression returns ANegateExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ANegateExpression
	 *     AMinMaxExpression returns ANegateExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ANegateExpression
	 *     AUnaryOrTerminalExpression returns ANegateExpression
	 *     AUnaryExpression returns ANegateExpression
	 *     ANegateExpression returns ANegateExpression
	 *
	 * Constraint:
	 *     (op=OP_MINUS expr=AAlphabetsTerminalExpression)
	 */
	protected void sequence_ANegateExpression(ISerializationContext context, ANegateExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ANEGATE_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ANEGATE_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ANEGATE_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ANEGATE_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getANegateExpressionAccess().getOpOP_MINUSTerminalRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getANegateExpressionAccess().getExprAAlphabetsTerminalExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ANotExpression
	 *     AAlphabetsTerminalExpression returns ANotExpression
	 *     AParanthesizedAlphabetsExpression returns ANotExpression
	 *     AOrExpression returns ANotExpression
	 *     AOrExpression.AOrExpression_1_0 returns ANotExpression
	 *     AAndExpression returns ANotExpression
	 *     AAndExpression.AAndExpression_1_0 returns ANotExpression
	 *     ARelationalExpression returns ANotExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ANotExpression
	 *     AAdditiveExpression returns ANotExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ANotExpression
	 *     AMultiplicativeExpression returns ANotExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ANotExpression
	 *     AMinMaxExpression returns ANotExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ANotExpression
	 *     AUnaryOrTerminalExpression returns ANotExpression
	 *     AUnaryExpression returns ANotExpression
	 *     ANotExpression returns ANotExpression
	 *
	 * Constraint:
	 *     (op='not' expr=AAlphabetsTerminalExpression)
	 */
	protected void sequence_ANotExpression(ISerializationContext context, ANotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ANOT_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ANOT_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ANOT_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ANOT_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getANotExpressionAccess().getOpNotKeyword_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getANotExpressionAccess().getExprAAlphabetsTerminalExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AOrExpression
	 *     AAlphabetsTerminalExpression returns AOrExpression
	 *     AParanthesizedAlphabetsExpression returns AOrExpression
	 *     AOrExpression returns AOrExpression
	 *     AOrExpression.AOrExpression_1_0 returns AOrExpression
	 *     AAndExpression returns AOrExpression
	 *     AAndExpression.AAndExpression_1_0 returns AOrExpression
	 *     ARelationalExpression returns AOrExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AOrExpression
	 *     AAdditiveExpression returns AOrExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AOrExpression
	 *     AMultiplicativeExpression returns AOrExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AOrExpression
	 *     AMinMaxExpression returns AOrExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AOrExpression
	 *     AUnaryOrTerminalExpression returns AOrExpression
	 *
	 * Constraint:
	 *     (left=AOrExpression_AOrExpression_1_0 (operator=OP_OR | operator=OP_XOR) right=AAndExpression)
	 */
	protected void sequence_AOrExpression(ISerializationContext context, AOrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns APackageDeclaration
	 *     APackageDeclaration returns APackageDeclaration
	 *
	 * Constraint:
	 *     (name=QualifiedName elements+=AbstractElement*)
	 */
	protected void sequence_APackageDeclaration(ISerializationContext context, APackageDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AParamDomain returns AParamDomain
	 *
	 * Constraint:
	 *     (dims=AIndexList constraintString=ISLString)
	 */
	protected void sequence_AParamDomain(ISerializationContext context, AParamDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.APARAM_DOMAIN__DIMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.APARAM_DOMAIN__DIMS));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.APARAM_DOMAIN__CONSTRAINT_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.APARAM_DOMAIN__CONSTRAINT_STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAParamDomainAccess().getDimsAIndexListParserRuleCall_1_0(), semanticObject.getDims());
		feeder.accept(grammarAccess.getAParamDomainAccess().getConstraintStringISLStringParserRuleCall_6_0(), semanticObject.getConstraintString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ARealExpression
	 *     AAlphabetsTerminalExpression returns ARealExpression
	 *     AParanthesizedAlphabetsExpression returns ARealExpression
	 *     AOrExpression returns ARealExpression
	 *     AOrExpression.AOrExpression_1_0 returns ARealExpression
	 *     AAndExpression returns ARealExpression
	 *     AAndExpression.AAndExpression_1_0 returns ARealExpression
	 *     ARelationalExpression returns ARealExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ARealExpression
	 *     AAdditiveExpression returns ARealExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ARealExpression
	 *     AMultiplicativeExpression returns ARealExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ARealExpression
	 *     AMinMaxExpression returns ARealExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ARealExpression
	 *     AUnaryOrTerminalExpression returns ARealExpression
	 *     AConstantExpression returns ARealExpression
	 *     ARealExpression returns ARealExpression
	 *
	 * Constraint:
	 *     value=REAL
	 */
	protected void sequence_ARealExpression(ISerializationContext context, ARealExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AREAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AREAL_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getARealExpressionAccess().getValueREALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AReduceExpression
	 *     AAlphabetsTerminalExpression returns AReduceExpression
	 *     AParanthesizedAlphabetsExpression returns AReduceExpression
	 *     AOrExpression returns AReduceExpression
	 *     AOrExpression.AOrExpression_1_0 returns AReduceExpression
	 *     AAndExpression returns AReduceExpression
	 *     AAndExpression.AAndExpression_1_0 returns AReduceExpression
	 *     ARelationalExpression returns AReduceExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AReduceExpression
	 *     AAdditiveExpression returns AReduceExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AReduceExpression
	 *     AMultiplicativeExpression returns AReduceExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AReduceExpression
	 *     AMinMaxExpression returns AReduceExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AReduceExpression
	 *     AUnaryOrTerminalExpression returns AReduceExpression
	 *     AReduceExpression returns AReduceExpression
	 *
	 * Constraint:
	 *     (op=AReductionOperator (projection=AFunction | projection=AFunctionInArrayNotation) expr=AAlphaExpression)
	 */
	protected void sequence_AReduceExpression(ISerializationContext context, AReduceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AReductionOperator returns AReductionOperator
	 *
	 * Constraint:
	 *     (op=[AExternalFunction|ID] | builtin=REDUCTION_OP)
	 */
	protected void sequence_AReductionOperator(ISerializationContext context, AReductionOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ARelation returns ARelation
	 *
	 * Constraint:
	 *     (inDims=AIndexList outDims=AIndexList constraintStr=ISLString)
	 */
	protected void sequence_ARelation(ISerializationContext context, ARelation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ARELATION__IN_DIMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ARELATION__IN_DIMS));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ARELATION__OUT_DIMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ARELATION__OUT_DIMS));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ARELATION__CONSTRAINT_STR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ARELATION__CONSTRAINT_STR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getARelationAccess().getInDimsAIndexListParserRuleCall_2_0(), semanticObject.getInDims());
		feeder.accept(grammarAccess.getARelationAccess().getOutDimsAIndexListParserRuleCall_6_0(), semanticObject.getOutDims());
		feeder.accept(grammarAccess.getARelationAccess().getConstraintStrISLStringParserRuleCall_8_0(), semanticObject.getConstraintStr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ARelationalExpression
	 *     AAlphabetsTerminalExpression returns ARelationalExpression
	 *     AParanthesizedAlphabetsExpression returns ARelationalExpression
	 *     AOrExpression returns ARelationalExpression
	 *     AOrExpression.AOrExpression_1_0 returns ARelationalExpression
	 *     AAndExpression returns ARelationalExpression
	 *     AAndExpression.AAndExpression_1_0 returns ARelationalExpression
	 *     ARelationalExpression returns ARelationalExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ARelationalExpression
	 *     AAdditiveExpression returns ARelationalExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ARelationalExpression
	 *     AMultiplicativeExpression returns ARelationalExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ARelationalExpression
	 *     AMinMaxExpression returns ARelationalExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ARelationalExpression
	 *     AUnaryOrTerminalExpression returns ARelationalExpression
	 *
	 * Constraint:
	 *     (left=ARelationalExpression_ARelationalExpression_1_0 operator=RELATIONAL_OP right=AAdditiveExpression)
	 */
	protected void sequence_ARelationalExpression(ISerializationContext context, ARelationalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ARELATIONAL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ARELATIONAL_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ARELATIONAL_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ARELATIONAL_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ARELATIONAL_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ARELATIONAL_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getARelationalExpressionAccess().getARelationalExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getARelationalExpressionAccess().getOperatorRELATIONAL_OPParserRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getARelationalExpressionAccess().getRightAAdditiveExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns ARestrictExpression
	 *     AAlphabetsTerminalExpression returns ARestrictExpression
	 *     AParanthesizedAlphabetsExpression returns ARestrictExpression
	 *     AOrExpression returns ARestrictExpression
	 *     AOrExpression.AOrExpression_1_0 returns ARestrictExpression
	 *     AAndExpression returns ARestrictExpression
	 *     AAndExpression.AAndExpression_1_0 returns ARestrictExpression
	 *     ARelationalExpression returns ARestrictExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns ARestrictExpression
	 *     AAdditiveExpression returns ARestrictExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns ARestrictExpression
	 *     AMultiplicativeExpression returns ARestrictExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns ARestrictExpression
	 *     AMinMaxExpression returns ARestrictExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns ARestrictExpression
	 *     AUnaryOrTerminalExpression returns ARestrictExpression
	 *     ARestrictExpression returns ARestrictExpression
	 *
	 * Constraint:
	 *     (domain=ADomain expr=AAlphaExpression)
	 */
	protected void sequence_ARestrictExpression(ISerializationContext context, ARestrictExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ARESTRICT_EXPRESSION__DOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ARESTRICT_EXPRESSION__DOMAIN));
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.ARESTRICT_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.ARESTRICT_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getARestrictExpressionAccess().getDomainADomainParserRuleCall_0_0(), semanticObject.getDomain());
		feeder.accept(grammarAccess.getARestrictExpressionAccess().getExprAAlphaExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AStart returns AStart
	 *
	 * Constraint:
	 *     elements+=AbstractElement+
	 */
	protected void sequence_AStart(ISerializationContext context, AStart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AUseEquation returns AUseEquation
	 *
	 * Constraint:
	 *     (
	 *         instantiationDomain=ADomain 
	 *         subsystemDims=AIndexList? 
	 *         (outputExprs+=AAlphaExpression outputExprs+=AAlphaExpression*)? 
	 *         system=[AAffineSystem|ID] 
	 *         callParams=AIndexList 
	 *         (inputExprs+=AAlphaExpression inputExprs+=AAlphaExpression*)?
	 *     )
	 */
	protected void sequence_AUseEquation(ISerializationContext context, AUseEquation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AVariableDeclaration returns AVariableDeclaration
	 *
	 * Constraint:
	 *     (varList+=AVariableList domain=ADomainExpression?)
	 */
	protected void sequence_AVariableDeclaration(ISerializationContext context, AVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ADomainExpression returns AVariableDomain
	 *     ADomainTerminal returns AVariableDomain
	 *     AVariableDomain returns AVariableDomain
	 *
	 * Constraint:
	 *     var=[AVariable|ID]
	 */
	protected void sequence_AVariableDomain(ISerializationContext context, AVariableDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AVARIABLE_DOMAIN__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AVARIABLE_DOMAIN__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAVariableDomainAccess().getVarAVariableIDTerminalRuleCall_2_0_1(), semanticObject.eGet(AlphaPackage.Literals.AVARIABLE_DOMAIN__VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AAlphaExpression returns AVariableExpression
	 *     AAlphabetsTerminalExpression returns AVariableExpression
	 *     AParanthesizedAlphabetsExpression returns AVariableExpression
	 *     AOrExpression returns AVariableExpression
	 *     AOrExpression.AOrExpression_1_0 returns AVariableExpression
	 *     AAndExpression returns AVariableExpression
	 *     AAndExpression.AAndExpression_1_0 returns AVariableExpression
	 *     ARelationalExpression returns AVariableExpression
	 *     ARelationalExpression.ARelationalExpression_1_0 returns AVariableExpression
	 *     AAdditiveExpression returns AVariableExpression
	 *     AAdditiveExpression.AAdditiveExpression_1_0 returns AVariableExpression
	 *     AMultiplicativeExpression returns AVariableExpression
	 *     AMultiplicativeExpression.AMultiplicativeExpression_1_0 returns AVariableExpression
	 *     AMinMaxExpression returns AVariableExpression
	 *     AMinMaxExpression.AMinMaxExpression_1_0 returns AVariableExpression
	 *     AUnaryOrTerminalExpression returns AVariableExpression
	 *     AVariableExpression returns AVariableExpression
	 *
	 * Constraint:
	 *     var=[AVariable|ID]
	 */
	protected void sequence_AVariableExpression(ISerializationContext context, AVariableExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AVARIABLE_EXPRESSION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AVARIABLE_EXPRESSION__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAVariableExpressionAccess().getVarAVariableIDTerminalRuleCall_0_1(), semanticObject.eGet(AlphaPackage.Literals.AVARIABLE_EXPRESSION__VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AVariableList returns AVariableList
	 *
	 * Constraint:
	 *     (vars+=AVariable vars+=AVariable*)
	 */
	protected void sequence_AVariableList(ISerializationContext context, AVariableList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AVariable returns AVariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_AVariable(ISerializationContext context, AVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlphaPackage.Literals.AVARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlphaPackage.Literals.AVARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
