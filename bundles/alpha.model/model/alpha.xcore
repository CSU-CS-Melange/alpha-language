@GenModel(
	operationReflection="false",
	loadInitialization="false",
	literalsInterface="true")
package alpha.model

import alpha.model.exception.CyclicDefinitionException
import alpha.model.util.AlphaUtil
import fr.irisa.cairn.jnimap.isl.jni.ISL_FORMAT
import fr.irisa.cairn.jnimap.isl.jni.JNIISLMap
import fr.irisa.cairn.jnimap.isl.jni.JNIISLUnionMap
import fr.irisa.cairn.jnimap.isl.jni.JNIISLMultiAff
import fr.irisa.cairn.jnimap.isl.jni.JNIISLSet
import fr.irisa.cairn.jnimap.runtime.JNIObject

//type JNIDomain wraps JNIDomain
type JNIObject wraps JNIObject
type JNIISLSet wraps JNIISLSet
type JNIISLMap wraps JNIISLMap
type JNIISLMultiAff wraps JNIISLMultiAff
type JNIISLUnionMap wraps JNIISLUnionMap
type ISL_FORMAT wraps ISL_FORMAT


/*
 * Some conventions:
 *  polyhedral objects are either domains or relations in Alpha terms
 * the above is distinguished from ISL objects that are named sets or maps
 * 
 * TODO make sure calculator expression does not have cycles in its evaluation chain
 *   VariableDomain and DefinedObject should only refer to textually preceding definitions
 */

interface AlphaNode {}


/**
 * Interface for AlphaCompleteVisitor, which actually is not complete in the sense it does not visit CalculatorExpression.
 * This is because CalculatorExpressions are seprate data structure to describe polyhedral objects, which is tightly
 * coupled with JNIISL.
 * 
 */
interface AlphaCompleteVisitable extends AlphaNode {} 

interface AlphaVisitable extends AlphaCompleteVisitable {
	op void accept(AlphaVisitor visitor)
}
interface AlphaExpressionVisitable extends AlphaCompleteVisitable {
	op void accept(AlphaExpressionVisitor visitor)
}

interface CalculatorExpressionVisitable extends AlphaNode {
	op void accept(CalculatorExpressionVisitor visitor)
}

interface DomainQualifiedElement {}

interface AlphaVisitor {
	op void visitAlphaRoot(AlphaRoot root)
	
	op void visitAlphaElement(AlphaElement ap)
	op void visitAlphaPackage(AlphaPackage ap)
	op void visitAlphaSystem(AlphaSystem system)
	op void visitImports(Imports imports)
	op void visitAlphaConstant(AlphaConstant ac)
	op void visitExternalFunction(ExternalFunction ef)
	
	/* Use specialized methods for input/output/local specific operations.
	 * The abstract visitor calls the specialized methods, which then calls the generic visitor.
	 */
	op void visitVariable(Variable variable)
	
	op void visitFuzzyVariable(FuzzyVariable variable)
	
	op void visitPolyhedralObject(PolyhedralObject pobj)

	op void visitUseEquation(UseEquation ue)
	op void visitStandardEquation(StandardEquation se)
	
	
	op void inAlphaRoot(AlphaRoot root)
	
	op void inAlphaElement(AlphaElement ap)
	op void inAlphaPackage(AlphaPackage ap)
	op void inAlphaSystem(AlphaSystem system)
	op void inImports(Imports imports)
	op void inAlphaConstant(AlphaConstant ac)
	op void inExternalFunction(ExternalFunction ef)
	
	op void inVariable(Variable variable)
	
	op void inFuzzyVariable(FuzzyVariable variable)
	
	op void inPolyhedralObject(PolyhedralObject pobj)

	op void inUseEquation(UseEquation ue)
	op void inStandardEquation(StandardEquation se)
	
	
	op void outAlphaRoot(AlphaRoot root)
	
	op void outAlphaElement(AlphaElement ap)
	op void outAlphaPackage(AlphaPackage ap)
	op void outAlphaSystem(AlphaSystem system)
	op void outImports(Imports imports)
	op void outAlphaConstant(AlphaConstant ac)
	op void outExternalFunction(ExternalFunction ef)
	
	op void outVariable(Variable variable)
	
	op void outFuzzyVariable(FuzzyVariable variable)
	
	op void outPolyhedralObject(PolyhedralObject pobj)

	op void outUseEquation(UseEquation ue)
	op void outStandardEquation(StandardEquation se)
}

interface AlphaExpressionVisitor {
	op void visitAlphaExpression(AlphaExpression ae)
	
	op void visitRestrictExpression(RestrictExpression re)
	op void visitAutoRestrictExpression(AutoRestrictExpression are)
	op void visitCaseExpression(CaseExpression ce)
	op void visitIfExpression(IfExpression ie)
	op void visitDependenceExpression(DependenceExpression de)
	op void visitFuzzyDependenceExpression(FuzzyDependenceExpression fde)
	op void visitAbstractReduceExpression(AbstractReduceExpression are)
	op void visitReduceExpression(ReduceExpression re)
	op void visitArgReduceExpression(ArgReduceExpression are)
	op void visitAbstractFuzzyReduceExpression(AbstractFuzzyReduceExpression afre)
	op void visitFuzzyReduceExpression(FuzzyReduceExpression fre)
	op void visitFuzzyArgReduceExpression(FuzzyArgReduceExpression fare)
	op void visitConvolutionExpression(ConvolutionExpression ce)
	op void visitUnaryExpression(UnaryExpression ue)
	op void visitBinaryExpression(BinaryExpression be)
	op void visitMultiArgExpression(MultiArgExpression mae)
	op void visitSelectExpression(SelectExpression se)
	
	op void visitIndexExpression(IndexExpression ie)
	op void visitFuzzyIndexExpression(FuzzyIndexExpression fie)
	op void visitVariableExpression(VariableExpression ve)
	
	op void visitConstantExpression(ConstantExpression ce)
	op void visitIntegerExpression(IntegerExpression ie)
	op void visitRealExpression(RealExpression re)
	op void visitBooleanExpression(BooleanExpression be)
	
	op void visitExternalReduceExpression(ExternalReduceExpression ere)
	op void visitExternalArgReduceExpression(ExternalArgReduceExpression eare)
	op void visitExternalMultiArgExpression(ExternalMultiArgExpression emae)
	op void visitExternalFuzzyReduceExpression(ExternalFuzzyReduceExpression efre)
	op void visitExternalFuzzyArgReduceExpression(ExternalFuzzyArgReduceExpression efare)
	
	
	op void inAlphaExpression(AlphaExpression ae)
	
	op void inRestrictExpression(RestrictExpression re)
	op void inAutoRestrictExpression(AutoRestrictExpression are)
	op void inCaseExpression(CaseExpression ce)
	op void inIfExpression(IfExpression ie)
	op void inDependenceExpression(DependenceExpression de)
	op void inFuzzyDependenceExpression(FuzzyDependenceExpression fde)
	op void inAbstractReduceExpression(AbstractReduceExpression are)
	op void inReduceExpression(ReduceExpression re)
	op void inArgReduceExpression(ArgReduceExpression are)
	op void inAbstractFuzzyReduceExpression(AbstractFuzzyReduceExpression afre)
	op void inFuzzyReduceExpression(FuzzyReduceExpression fre)
	op void inFuzzyArgReduceExpression(FuzzyArgReduceExpression fare)
	op void inConvolutionExpression(ConvolutionExpression ce)
	op void inUnaryExpression(UnaryExpression ue)
	op void inBinaryExpression(BinaryExpression be)
	op void inMultiArgExpression(MultiArgExpression mae)
	op void inSelectExpression(SelectExpression se)
	
	op void inIndexExpression(IndexExpression ie)
	op void inFuzzyIndexExpression(FuzzyIndexExpression fie)
	op void inVariableExpression(VariableExpression ve)
	
	op void inConstantExpression(ConstantExpression ce)
	op void inIntegerExpression(IntegerExpression ie)
	op void inRealExpression(RealExpression re)
	op void inBooleanExpression(BooleanExpression be)
	
	op void inExternalReduceExpression(ExternalReduceExpression ere)
	op void inExternalArgReduceExpression(ExternalArgReduceExpression eare)
	op void inExternalMultiArgExpression(ExternalMultiArgExpression emae)
	op void inExternalFuzzyReduceExpression(ExternalFuzzyReduceExpression efre)
	op void inExternalFuzzyArgReduceExpression(ExternalFuzzyArgReduceExpression efare)
	
	op void outAlphaExpression(AlphaExpression ae)
	
	op void outRestrictExpression(RestrictExpression re)
	op void outAutoRestrictExpression(AutoRestrictExpression are)
	op void outCaseExpression(CaseExpression ce)
	op void outIfExpression(IfExpression ie)
	op void outDependenceExpression(DependenceExpression de)
	op void outFuzzyDependenceExpression(FuzzyDependenceExpression fde)
	op void outAbstractReduceExpression(AbstractReduceExpression are)
	op void outReduceExpression(ReduceExpression re)
	op void outArgReduceExpression(ArgReduceExpression are)
	op void outAbstractFuzzyReduceExpression(AbstractFuzzyReduceExpression afre)
	op void outFuzzyReduceExpression(FuzzyReduceExpression fre)
	op void outFuzzyArgReduceExpression(FuzzyArgReduceExpression fare)
	op void outConvolutionExpression(ConvolutionExpression ce)
	op void outUnaryExpression(UnaryExpression ue)
	op void outBinaryExpression(BinaryExpression be)
	op void outMultiArgExpression(MultiArgExpression mae)
	op void outSelectExpression(SelectExpression se)
	
	op void outIndexExpression(IndexExpression ie)
	op void outFuzzyIndexExpression(FuzzyIndexExpression fie)
	op void outVariableExpression(VariableExpression ve)
	
	op void outConstantExpression(ConstantExpression ce)
	op void outIntegerExpression(IntegerExpression ie)
	op void outRealExpression(RealExpression re)
	op void outBooleanExpression(BooleanExpression be)
	
	op void outExternalReduceExpression(ExternalReduceExpression ere)
	op void outExternalArgReduceExpression(ExternalArgReduceExpression eare)
	op void outExternalMultiArgExpression(ExternalMultiArgExpression emae)
	op void outExternalFuzzyReduceExpression(ExternalFuzzyReduceExpression efre)
	op void outExternalFuzzyArgReduceExpression(ExternalFuzzyArgReduceExpression efare)
}

interface CalculatorExpressionVisitor {
	op void visitCalculatorExpression(CalculatorExpression expr)
	
	op void visitUnaryCalculatorExpression(UnaryCalculatorExpression expr)
	op void visitBinaryCalculatorExpression(BinaryCalculatorExpression expr)
	
	op void visitJNIDomain(JNIDomain jniDomain)
	op void visitJNIRelation(JNIRelation jniRelation)
	op void visitJNIFunction(JNIFunction jniFunction)
	
	op void visitVariableDomain(VariableDomain vdom)
	op void visitRectangularDomain(RectangularDomain rdom)
	op void visitDefinedObject(DefinedObject dobj)
}

class AlphaRoot extends AlphaVisitable {
	contains AlphaElement[] elements
	
	op Imports[] getImports() { elements.filter(Imports).asEList }
	op AlphaConstant[] getConstants() { elements.filter(AlphaConstant).asEList }
	op ExternalFunction[] getExternalFunctions() { elements.filter(ExternalFunction).asEList }
	op AlphaPackage[] getPackages() { elements.filter(AlphaPackage).asEList }
	op AlphaSystem[] getSystems() { elements.filter(AlphaSystem).asEList }
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaRoot(this)
	}
}

abstract class AlphaElement extends AlphaVisitable {
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaElement(this)
	}
}

class Imports extends AlphaElement {
	String importedNamespace
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitImports(this)
	}
}

class AlphaPackage extends AlphaElement {
	 id String name
	 contains AlphaElement[] elements
	 
	op AlphaConstant[] getConstants() { elements.filter(AlphaConstant).asEList }
	op ExternalFunction[] getExternalFunctions() { elements.filter(ExternalFunction).asEList }
	op AlphaPackage[] getPackages() { elements.filter(AlphaPackage).asEList }
	op AlphaSystem[] getSystems() { elements.filter(AlphaSystem).asEList }
	 
	 op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaPackage(this)
	}
}

class AlphaConstant extends AlphaElement {
	String name
	int value 
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaConstant(this)
	}
}

class ExternalFunction extends AlphaElement {
	String name
	int cardinality
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitExternalFunction(this)
	}
}

class AlphaSystem extends AlphaElement {
	String name
	contains JNIDomain parameterDomainExpr
	contains PolyhedralObject[] definedObjects
	contains Variable[] inputs
	contains Variable[] outputs
	contains Variable[] locals
	contains CalculatorExpression whileDomainExpr
	contains AlphaExpression testExpression
	
	contains UseEquation[] useEquations
	contains StandardEquation[] equations
	
	op Variable[] getVariables() {
		(inputs+outputs+locals).asEList.unmodifiableEList
	}
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaSystem(this)
	}
	
	op JNIISLSet getParameterDomain() {
		return parameterDomainExpr.ISLSet
	}
	
	op JNIISLSet getWhileDomain() {
		if (whileDomainExpr === null || whileDomainExpr.^type != POLY_OBJECT_TYPE::SET) null 
		else (whileDomainExpr.ISLObject as JNIISLSet).copy
	}
}


class Variable extends AlphaVisitable {
	String name
	contains CalculatorExpression domainExpr
	
	op JNIISLSet getDomain() {
		if (domainExpr.^type != POLY_OBJECT_TYPE::SET) {
			return null
		}
		
		try {
			return if (domainExpr.^type != POLY_OBJECT_TYPE::SET) null else domainExpr.ISLObject as JNIISLSet
		} catch (CyclicDefinitionException cde) {
			return null
		}
	}
	
	op boolean isInput() {
		eContainmentFeature !== null && eContainmentFeature === ModelPackage.Literals.ALPHA_SYSTEM__INPUTS
	}
	op boolean isOutput() {
		eContainmentFeature !== null && eContainmentFeature === ModelPackage.Literals.ALPHA_SYSTEM__OUTPUTS
	}
	op boolean isLocal() {
		eContainmentFeature !== null && eContainmentFeature === ModelPackage.Literals.ALPHA_SYSTEM__LOCALS
	}
	
	 op void accept(AlphaVisitor visitor) {
	 	visitor.visitVariable(this)
	}
}

class FuzzyVariable extends Variable {
	contains CalculatorExpression rangeExpr
	
	op JNIISLSet getRange() {
		return if (rangeExpr.^type != POLY_OBJECT_TYPE::SET) null else rangeExpr.ISLObject as JNIISLSet
	}
	
	op JNIISLMap getRelation() {
		val dom = domain
		val ran = range
		if (dom === null || ran === null) null else dom.product(ran).unwrap
	}
	
	op void accept(AlphaVisitor visitor) {
	 	visitor.visitFuzzyVariable(this)
	}
}

class StandardEquation extends AlphaVisitable {
	refers Variable variable
	String[] indexNames
	contains AlphaExpression expr
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitStandardEquation(this)
	}
}
class UseEquation extends AlphaVisitable {
	refers AlphaSystem system
	contains CalculatorExpression instantiationDomainExpr
	contains JNIFunctionInArrayNotation callParamsExpr
	String[] subsystemDims
	contains AlphaExpression[] inputExprs
	contains AlphaExpression[] outputExprs
	
	
	op JNIISLSet getInstantiationDomain() {
		if (instantiationDomainExpr.^type != POLY_OBJECT_TYPE.SET) null
		else instantiationDomainExpr.ISLObject as JNIISLSet
	}
	
	op JNIISLMultiAff getCallParams() {
		if (callParamsExpr.^type != POLY_OBJECT_TYPE.FUNCTION) null
		else callParamsExpr.ISLObject as JNIISLMultiAff
	}
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitUseEquation(this)
	}
}

/** Alpha Expressions */

abstract class AlphaExpression extends AlphaExpressionVisitable {
	/*Internal object for always copying expression domain at getter */
	JNIISLSet z__internal_cache_exprDom
	/*Internal object for always copying context domain at getter */
	JNIISLSet z__internal_cache_contextDom
	String errorMessage
	
	op void setExpressionDomain(JNIISLSet dom) { this.setZ__internal_cache_exprDom(dom) }
	op JNIISLSet getExpressionDomain() { if (z__internal_cache_exprDom !== null) z__internal_cache_exprDom.copy else null }
	
	op void setContextDomain(JNIISLSet dom) { this.setZ__internal_cache_contextDom(dom) }
	op JNIISLSet getContextDomain() { if (z__internal_cache_contextDom !== null)  z__internal_cache_contextDom.copy else null }
}

class RestrictExpression extends AlphaExpression {
	contains CalculatorExpression domainExpr
	contains AlphaExpression expr
	
	op JNIISLSet getRestrictDomain() {
		if (domainExpr.^type != POLY_OBJECT_TYPE.SET ) null
		else domainExpr.ISLObject as JNIISLSet
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitRestrictExpression(this)
	}
}
class AutoRestrictExpression extends AlphaExpression {
	contains AlphaExpression expr
	JNIISLSet z__internal_cache_inferredDomain
	
	op JNIISLSet getInferredDomain() { if (z__internal_cache_inferredDomain !== null) z__internal_cache_inferredDomain.copy else null }
	op void setInferredDomain(JNIISLSet islset) { z__internal_cache_inferredDomain = islset }
		
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAutoRestrictExpression(this)
	}
}

class CaseExpression extends AlphaExpression {
	String name
	contains AlphaExpression[] exprs
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitCaseExpression(this)
	}
}
class DependenceExpression extends AlphaExpression {
	contains JNIFunction functionExpr
	contains AlphaExpression expr
	
	op JNIISLMultiAff getFunction() {
		if (functionExpr.^type != POLY_OBJECT_TYPE.FUNCTION ) null
		else functionExpr.ISLObject as JNIISLMultiAff
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitDependenceExpression(this)
	}
}
class FuzzyDependenceExpression extends AlphaExpression {
	contains FuzzyFunction fuzzyFunction
	contains AlphaExpression expr
	
	op JNIISLMap getDependenceRelation() {
		if (fuzzyFunction !== null) fuzzyFunction.dependenceRelation else null
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitFuzzyDependenceExpression(this)
	}
}
class IfExpression extends AlphaExpression {
	contains AlphaExpression condExpr
	contains AlphaExpression thenExpr
	contains AlphaExpression elseExpr
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitIfExpression(this)
	}
}
class IndexExpression extends AlphaExpression {
	contains JNIFunction functionExpr
	
	op JNIISLMultiAff getFunction() {
		if (functionExpr.^type != POLY_OBJECT_TYPE.FUNCTION ) null
		else functionExpr.ISLObject as JNIISLMultiAff
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitIndexExpression(this)
	}
}

class FuzzyIndexExpression extends AlphaExpression {	
	contains FuzzyFunction fuzzyFunction
	
	op JNIISLMap getDependenceRelation() {
		if (fuzzyFunction !== null) fuzzyFunction.dependenceRelation else null
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitFuzzyIndexExpression(this)
	}
}


abstract class AbstractReduceExpression extends AlphaExpression {
	REDUCTION_OP operator
	contains JNIFunction projectionExpr
	contains AlphaExpression body
	
	op JNIISLMultiAff getProjection() {
		if (projectionExpr.^type != POLY_OBJECT_TYPE.FUNCTION ) null
		else projectionExpr.ISLObject as JNIISLMultiAff
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractReduceExpression(this)
	}
}
class ReduceExpression extends AbstractReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitReduceExpression(this)
	}
}
class ExternalReduceExpression extends ReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitExternalReduceExpression(this)
	}
}
class ArgReduceExpression extends AbstractReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitArgReduceExpression(this)
	}
}
class ExternalArgReduceExpression extends ArgReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitExternalArgReduceExpression(this)
	}
}
class ConvolutionExpression extends AlphaExpression {
	contains CalculatorExpression kernelDomainExpr
	contains AlphaExpression kernelExpression
	contains AlphaExpression dataExpression
	
	op JNIISLSet getKernelDomain() {
		if (kernelDomainExpr.^type != POLY_OBJECT_TYPE.SET ) null
		else kernelDomainExpr.ISLObject as JNIISLSet
	}

	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitConvolutionExpression(this)
	}
}
class SelectExpression extends AlphaExpression {
	contains CalculatorExpression relationExpr
	contains AlphaExpression expr
	
	op JNIISLMap getSelectRelation() {
		if (relationExpr.^type != POLY_OBJECT_TYPE.MAP) null
		else relationExpr.ISLObject as JNIISLMap
	}

	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitSelectExpression(this)
	}
}
class VariableExpression extends AlphaExpression {
	refers Variable variable
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitVariableExpression(this)
	}
}
abstract class ConstantExpression extends AlphaExpression {
	
	op String valueString()
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitConstantExpression(this)
	}
}
class IntegerExpression extends ConstantExpression {
	int value
	
	op String valueString() { value+"" }
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitIntegerExpression(this)
	}
}
class RealExpression extends ConstantExpression {
	float value
	
	op String valueString() { value+"" }
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitRealExpression(this)
	}
}
class BooleanExpression extends ConstantExpression {
	boolean value
	
	op String valueString() { value+"" }
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitBooleanExpression(this)
	}
}
class UnaryExpression extends AlphaExpression {
	UNARY_OP operator
	contains AlphaExpression expr
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitUnaryExpression(this)
	}
}
class BinaryExpression extends AlphaExpression {
	BINARY_OP operator
	contains AlphaExpression left
	contains AlphaExpression right
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitBinaryExpression(this)
	}
}
class MultiArgExpression extends AlphaExpression {
	REDUCTION_OP operator
	contains AlphaExpression[] exprs
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitMultiArgExpression(this)
	}
}
class ExternalMultiArgExpression extends MultiArgExpression {
	refers ExternalFunction externalFunction 
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitExternalMultiArgExpression(this)
	}
}

abstract class AbstractFuzzyReduceExpression extends AlphaExpression {
	REDUCTION_OP operator
	contains FuzzyFunction projectionFunction
	contains AlphaExpression body
	
	op JNIISLMap getProjection() {
		if (projectionFunction !== null) projectionFunction.dependenceRelation else null
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractFuzzyReduceExpression(this)
	}
}
class FuzzyReduceExpression extends AbstractFuzzyReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitFuzzyReduceExpression(this)
	}
}
class ExternalFuzzyReduceExpression extends FuzzyReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitExternalFuzzyReduceExpression(this)
	}
}
class FuzzyArgReduceExpression extends AbstractFuzzyReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitFuzzyArgReduceExpression(this)
	}
}
class ExternalFuzzyArgReduceExpression extends FuzzyArgReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitExternalFuzzyArgReduceExpression(this)
	}
}

enum UNARY_OP {
	NOT as "not"
	NEGATE as "-"
}

enum BINARY_OP {
	MIN as "min"
	MAX as "max"
	
	MUL as "*"
	DIV as "/"
	MOD as "%"
	
	ADD as "+"
	SUB as "-"
	
	AND as "and"
	OR  as "or"
	XOR as "xor"
	
	EQ as "="
	NE as "!="
	GE as ">="
	GT as ">"
	LE as "<="
	LT as "<"
}

enum REDUCTION_OP {
	MIN as "min"
	MAX as "max"
	PROD as "prod"
	SUM as "sum"
	AND as "and"
	OR as "or"
	XOR as "xor"
	
	EX as "external"
}


/** Calculator Expressions **/
enum POLY_OBJECT_TYPE {
	SET
	MAP
	FUNCTION
}

enum CALCULATOR_UNARY_OP {
	GET_DOMAIN as "domain"
	GET_RANGE as "range"
	COMPLEMENT as "complement"
	POLYHEDRAL_HULL as "poly-hull"
	AFFINE_HULL as "affine-hull"
	REVERSE as "reverse"
}

enum CALCULATOR_BINARY_OP {
	INTERSECT as "*"
	UNION as "+"
	CROSS_PRODUCT as "cross"
	SET_DIFFERENCE as "-"
	JOIN as "@"
	INTERSECT_RANGE as "->*"
	SUBTRACT_RANGE as "->-"
}

interface CalculatorNode {
	op POLY_OBJECT_TYPE getType()
	op JNIObject getISLObject()
}

class PolyhedralObject extends CalculatorNode, AlphaVisitable {
	String name
	contains CalculatorExpression expr
	
	op POLY_OBJECT_TYPE getType() { expr.^type }
	op JNIObject getISLObject() { 
		AlphaUtil.copy(expr.ISLObject)
	}
	
	op void accept(AlphaVisitor visitor) {
	 	visitor.visitPolyhedralObject(this)
	}
}

abstract class CalculatorExpression extends CalculatorNode, CalculatorExpressionVisitable {
//	String errorMessage
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitCalculatorExpression(this);
	}
	
	/**
	 * toString without using ISL objects 
	 */
	op String plainToString() {
		throw new UnsupportedOperationException();
	}
}

class JNIDomain extends CalculatorExpression {
	String islString
	JNIISLSet z__internal_cache_islSet
	
	op JNIISLSet getISLSet() { if (z__internal_cache_islSet !== null) z__internal_cache_islSet.copy else null }
	op void setISLSet(JNIISLSet islset) { z__internal_cache_islSet = islset }
	
	op POLY_OBJECT_TYPE getType() { if (z__internal_cache_islSet !== null) POLY_OBJECT_TYPE::SET  else null }
	op JNIObject getISLObject() { getISLSet }
	
	op String toString() {
		if (z__internal_cache_islSet !== null) {
			return z__internal_cache_islSet.toString(ISL_FORMAT::ISL);
		} else {
			return "null ISL object"
		}
	}
	
	op String plainToString() {
		islString
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitJNIDomain(this);
	}
}
class JNIDomainInArrayNotation extends JNIDomain {
	
}

class JNIRelation extends CalculatorExpression {
	String islString
	JNIISLMap z__internal_cache_islMap
	
	op JNIISLMap getISLMap() { if (z__internal_cache_islMap !== null) z__internal_cache_islMap.copy else null }
	op void setISLMap(JNIISLMap islMap) { z__internal_cache_islMap = islMap }
	
	op POLY_OBJECT_TYPE getType() { if (z__internal_cache_islMap !== null) POLY_OBJECT_TYPE::MAP else null }
	op JNIObject getISLObject() { ISLMap }
	
	op String toString() {
		if (z__internal_cache_islMap !== null) {
			return z__internal_cache_islMap.toString(ISL_FORMAT::ISL);
		} else {
			return "null ISL object"
		}
	}
	
	op String plainToString() {
		islString
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitJNIRelation(this);
	}
}

class JNIFunction extends CalculatorExpression {
	String alphaString
	JNIISLMultiAff z__internal_cache_islMAff
	
	op JNIISLMultiAff getISLMultiAff() { if (z__internal_cache_islMAff !== null) z__internal_cache_islMAff.copy else null }
	op void setISLMultiAff(JNIISLMultiAff islMAff) { z__internal_cache_islMAff = islMAff }
	
	op POLY_OBJECT_TYPE getType() { if (z__internal_cache_islMAff !== null) POLY_OBJECT_TYPE::FUNCTION else null }
	op JNIObject getISLObject() { ISLMultiAff }
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitJNIFunction(this);
	}
	
	op String plainToString() {
		alphaString
	}
}

class JNIFunctionInArrayNotation extends JNIFunction {
	String[] arrayNotation
	
	op String plainToString() {
		'[' + arrayNotation.join(",") + ']'
	}
}

class FuzzyFunction extends AlphaNode {
	String alphaString
	contains FuzzyVariableUse[] indirections
	JNIISLMap z__internal_cache_fuzzyMap
	JNIISLMap z__internal_cache_depRelation
	
	op JNIISLMap getFuzzyMap() { if (z__internal_cache_fuzzyMap !== null) z__internal_cache_fuzzyMap.copy else null }
	op void setFuzzyMap(JNIISLMap fuzzyMap) { z__internal_cache_fuzzyMap = fuzzyMap }
	
	op JNIISLMap getDependenceRelation() { if (z__internal_cache_depRelation !== null) z__internal_cache_depRelation.copy else null }
	op void setDependenceRelation(JNIISLMap depRel) { z__internal_cache_depRelation = depRel }
	
	op FuzzyVariableUse getIndirectionByName(String name) {
		indirections.findFirst[i|i.fuzzyIndex.contentEquals(name)]	
	}
	
}

abstract class FuzzyVariableUse extends AlphaNode {
	String fuzzyIndex
	refers FuzzyVariable fuzzyVariable

	//This method is identical to that in FuzzyFunction
	// 	however, AffineFuzzyVariable use do not inherit from FuzzyFunction, so we need a separate declaration
	op JNIISLMap getDependenceRelation()
}

class NestedFuzzyFunction extends FuzzyFunction, FuzzyVariableUse {
}

class AffineFuzzyVariableUse extends FuzzyVariableUse {
	contains JNIFunctionInArrayNotation useFunction
	
	op JNIISLMap getDependenceRelation() { 
		if (useFunction !== null && fuzzyVariable !== null && fuzzyVariable.relation !== null) 
			useFunction.ISLMultiAff.toMap.applyRange(fuzzyVariable.relation)
		else null
	}
}

class FuzzyFunctionInArrayNotation extends FuzzyFunction {
	String[] arrayNotation
	
	op String plainToString() {
		'[' + arrayNotation.join(",") + ']'
	}
}

class UnaryCalculatorExpression extends CalculatorExpression {
	CALCULATOR_UNARY_OP operator
	contains CalculatorExpression expr
	
	JNIObject z__internal_cache_islObject
	
	op POLY_OBJECT_TYPE getType() { 
		if (z__internal_cache_islObject instanceof JNIISLSet)
			return POLY_OBJECT_TYPE::SET
		if (z__internal_cache_islObject instanceof JNIISLMap)
			return POLY_OBJECT_TYPE::MAP
		return null
	}
	op JNIObject getISLObject() { 
		AlphaUtil.copy(z__internal_cache_islObject)
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitUnaryCalculatorExpression(this);
	}
	
	op String plainToString() {
		operator + ' ' + expr.plainToString
	}
}

class BinaryCalculatorExpression extends CalculatorExpression {
	CALCULATOR_BINARY_OP operator
	contains CalculatorExpression left
	contains CalculatorExpression right
	
	JNIObject z__internal_cache_islObject
	
	op POLY_OBJECT_TYPE getType() { 
		if (z__internal_cache_islObject instanceof JNIISLSet)
			return POLY_OBJECT_TYPE::SET
		if (z__internal_cache_islObject instanceof JNIISLMap)
			return POLY_OBJECT_TYPE::MAP
		return null
	}
	
	op JNIObject getISLObject() { 
		AlphaUtil.copy(z__internal_cache_islObject)
	}

	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitBinaryCalculatorExpression(this);
	}
	
	op String plainToString() {
		left.plainToString + ' ' + operator + ' ' + right.plainToString
	}
}

/* VariableDomain refers to the domain of declared variables */
class VariableDomain extends CalculatorExpression {
	refers Variable variable
	
	op POLY_OBJECT_TYPE getType() { return POLY_OBJECT_TYPE::SET }
	op JNIObject getISLObject() { if (variable !== null) variable.domain else null }
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitVariableDomain(this);
	}
	
	op String plainToString() {
		'{' + variable.name + '}'
	}
}

/* RectangularDomain is a short-hand for rectilinear domains bounded by 0 from below, and by some parameter from above.
 * The dimensionality of the domain is the length of upperBounds that give the upper bound for each dimension.
 * The index names can be optionally specified for each dimension. (It is not possible to only name a subset of the dimensions.)
 * 
 * The bounds are of the form: 0<=i<N; each dimension will have N integer points starting from 0. 
 */
class RectangularDomain extends CalculatorExpression {
	String[] upperBounds
	String[] indexNames
	
	JNIISLSet z__internal_cache_islSet
	
	op JNIISLSet getISLSet() { if (z__internal_cache_islSet !== null) z__internal_cache_islSet.copy else null}
	op void setISLSet(JNIISLSet islset) { z__internal_cache_islSet = islset }
	
	op POLY_OBJECT_TYPE getType() { return POLY_OBJECT_TYPE::SET }
	op JNIObject getISLObject() { ISLSet }
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitRectangularDomain(this);
	}
	
	op String plainToString() {
		'[' + upperBounds.join(", ") + ']'
	}
}

/* Reference to an already defined object in the calculator section */
class DefinedObject extends CalculatorExpression {
	refers PolyhedralObject object
	boolean z__internalCycleDetector
	
	op POLY_OBJECT_TYPE getType() { return object.getType }
	op JNIObject getISLObject() {
		
		if (object !== null) {
			if (z__internalCycleDetector) {
				throw new CyclicDefinitionException("Cycle detected in the definition of: " + object.name);
			}
			z__internalCycleDetector = true;
			val res = object.ISLObject
			z__internalCycleDetector = false
			return res
		}
		return null
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitDefinedObject(this);
	}
	
	op String plainToString() {
		object.name
	}
}
