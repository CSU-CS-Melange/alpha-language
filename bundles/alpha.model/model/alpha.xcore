@GenModel(
	operationReflection="false",
	loadInitialization="false",
	literalsInterface="true")
package alpha.model

import alpha.model.issue.CyclicDefinitionException
import alpha.model.util.AlphaUtil
import fr.irisa.cairn.jnimap.isl.jni.ISL_FORMAT
import fr.irisa.cairn.jnimap.isl.jni.JNIISLMap
import fr.irisa.cairn.jnimap.isl.jni.JNIISLMultiAff
import fr.irisa.cairn.jnimap.isl.jni.JNIISLSet
import fr.irisa.cairn.jnimap.runtime.JNIObject

//type JNIDomain wraps JNIDomain
type JNIObject wraps JNIObject
type JNIISLSet wraps JNIISLSet
type JNIISLMap wraps JNIISLMap
type JNIISLMultiAff wraps JNIISLMultiAff
type ISL_FORMAT wraps ISL_FORMAT


/*
 * Some conventions:
 *  polyhedral objects are either domains or relations in Alpha terms
 * the above is distinguished from ISL objects that are named sets or maps
 * 
 * TODO make sure calculator expression does not have cycles in its evaluation chain
 *   VariableDomain and DefinedObject should only refer to textually preceding definitions
 */

interface AlphaNode {}

interface AlphaVisitable extends AlphaNode {
	op void accept(AlphaVisitor visitor)
}
interface AlphaExpressionVisitable extends AlphaNode {
	op void accept(AlphaExpressionVisitor visitor)
}

interface CalculatorExpressionVisitable extends AlphaNode {
	op void accept(CalculatorExpressionVisitor visitor)
}

interface DomainQualifiedElement {}

interface AlphaVisitor {
	op void visitAlphaRoot(AlphaRoot root)
	
	op void visitAlphaElement(AlphaElement ap)
	op void visitAlphaPackage(AlphaPackage ap)
	op void visitAlphaSystem(AlphaSystem system)
	op void visitImports(Imports imports)
	op void visitAlphaConstant(AlphaConstant ac)
	op void visitExternalFunction(ExternalFunction ef)
	
	/* Use specialized methods for input/output/local specific operations.
	 * The abstract visitor calls the specialized methods, which then calls the generic visitor.
	 */
	op void visitVariable(Variable variable)
	
	/* Use visitVariable for generic operations */
	op void visitInputVariable(InputVariable variable)
	/* Use visitVariable for generic operations */
	op void visitOutputVariable(OutputVariable variable)
	/* Use visitVariable for generic operations */
	op void visitLocalVariable(LocalVariable variable)
	op void visitFuzzyVariable(FuzzyVariable variable)
	
	op void visitPolyhedralObject(PolyhedralObject pobj)

	op void visitUseEquation(UseEquation ue)
	op void visitStandardEquation(StandardEquation se)
	
	
	op void inAlphaRoot(AlphaRoot root)
	
	op void inAlphaElement(AlphaElement ap)
	op void inAlphaPackage(AlphaPackage ap)
	op void inAlphaSystem(AlphaSystem system)
	op void inImports(Imports imports)
	op void inAlphaConstant(AlphaConstant ac)
	op void inExternalFunction(ExternalFunction ef)
	
	op void inVariable(Variable variable)
	
	op void inInputVariable(InputVariable variable)
	op void inOutputVariable(OutputVariable variable)
	op void inLocalVariable(LocalVariable variable)
	op void inFuzzyVariable(FuzzyVariable variable)
	
	op void inPolyhedralObject(PolyhedralObject pobj)

	op void inUseEquation(UseEquation ue)
	op void inStandardEquation(StandardEquation se)
	
	
	op void outAlphaRoot(AlphaRoot root)
	
	op void outAlphaElement(AlphaElement ap)
	op void outAlphaPackage(AlphaPackage ap)
	op void outAlphaSystem(AlphaSystem system)
	op void outImports(Imports imports)
	op void outAlphaConstant(AlphaConstant ac)
	op void outExternalFunction(ExternalFunction ef)
	
	op void outVariable(Variable variable)
	
	op void outInputVariable(InputVariable variable)
	op void outOutputVariable(OutputVariable variable)
	op void outLocalVariable(LocalVariable variable)
	op void outFuzzyVariable(FuzzyVariable variable)
	
	op void outPolyhedralObject(PolyhedralObject pobj)

	op void outUseEquation(UseEquation ue)
	op void outStandardEquation(StandardEquation se)
}

interface AlphaExpressionVisitor {
	op void visitAlphaExpression(AlphaExpression ae)
	
	op void visitRestrictExpression(RestrictExpression re)
	op void visitAutoRestrictExpression(AutoRestrictExpression are)
	op void visitCaseExpression(CaseExpression ce)
	op void visitIfExpression(IfExpression ie)
	op void visitDependenceExpression(DependenceExpression de)
	op void visitAbstractReduceExpression(AbstractReduceExpression are)
	op void visitReduceExpression(ReduceExpression re)
	op void visitArgReduceExpression(ArgReduceExpression are)
	op void visitConvolutionExpression(ConvolutionExpression ce)
	op void visitUnaryExpression(UnaryExpression ue)
	op void visitBinaryExpression(BinaryExpression be)
	op void visitMultiArgExpression(MultiArgExpression mae)
	op void visitSelectExpression(SelectExpression se)
	
	op void visitIndexExpression(IndexExpression ie)
	op void visitVariableExpression(VariableExpression ve)
	
	op void visitConstantExpression(ConstantExpression ce)
	op void visitIntegerExpression(IntegerExpression ie)
	op void visitRealExpression(RealExpression re)
	op void visitBooleanExpression(BooleanExpression be)
	
	op void visitExternalReduceExpression(ExternalReduceExpression ere)
	op void visitExternalArgReduceExpression(ExternalArgReduceExpression eare)
	op void visitExternalMultiArgExpression(ExternalMultiArgExpression emae)
	
	
	op void inAlphaExpression(AlphaExpression ae)
	
	op void inRestrictExpression(RestrictExpression re)
	op void inAutoRestrictExpression(AutoRestrictExpression are)
	op void inCaseExpression(CaseExpression ce)
	op void inIfExpression(IfExpression ie)
	op void inDependenceExpression(DependenceExpression de)
	op void inAbstractReduceExpression(AbstractReduceExpression are)
	op void inReduceExpression(ReduceExpression re)
	op void inArgReduceExpression(ArgReduceExpression are)
	op void inConvolutionExpression(ConvolutionExpression ce)
	op void inUnaryExpression(UnaryExpression ue)
	op void inBinaryExpression(BinaryExpression be)
	op void inMultiArgExpression(MultiArgExpression mae)
	op void inSelectExpression(SelectExpression se)
	
	op void inIndexExpression(IndexExpression ie)
	op void inVariableExpression(VariableExpression ve)
	
	op void inConstantExpression(ConstantExpression ce)
	op void inIntegerExpression(IntegerExpression ie)
	op void inRealExpression(RealExpression re)
	op void inBooleanExpression(BooleanExpression be)
	
	op void inExternalReduceExpression(ExternalReduceExpression ere)
	op void inExternalArgReduceExpression(ExternalArgReduceExpression eare)
	op void inExternalMultiArgExpression(ExternalMultiArgExpression emae)
	
	op void outAlphaExpression(AlphaExpression ae)
	
	op void outRestrictExpression(RestrictExpression re)
	op void outAutoRestrictExpression(AutoRestrictExpression are)
	op void outCaseExpression(CaseExpression ce)
	op void outIfExpression(IfExpression ie)
	op void outDependenceExpression(DependenceExpression de)
	op void outAbstractReduceExpression(AbstractReduceExpression are)
	op void outReduceExpression(ReduceExpression re)
	op void outArgReduceExpression(ArgReduceExpression are)
	op void outConvolutionExpression(ConvolutionExpression ce)
	op void outUnaryExpression(UnaryExpression ue)
	op void outBinaryExpression(BinaryExpression be)
	op void outMultiArgExpression(MultiArgExpression mae)
	op void outSelectExpression(SelectExpression se)
	
	op void outIndexExpression(IndexExpression ie)
	op void outVariableExpression(VariableExpression ve)
	
	op void outConstantExpression(ConstantExpression ce)
	op void outIntegerExpression(IntegerExpression ie)
	op void outRealExpression(RealExpression re)
	op void outBooleanExpression(BooleanExpression be)
	
	op void outExternalReduceExpression(ExternalReduceExpression ere)
	op void outExternalArgReduceExpression(ExternalArgReduceExpression eare)
	op void outExternalMultiArgExpression(ExternalMultiArgExpression emae)
}

interface CalculatorExpressionVisitor {
	op void visitCalculatorExpression(CalculatorExpression expr)
	
	op void visitUnaryCalculatorExpression(UnaryCalculatorExpression expr)
	op void visitBinaryCalculatorExpression(BinaryCalculatorExpression expr)
	
	op void visitJNIDomain(JNIDomain jniDomain)
	op void visitJNIRelation(JNIRelation jniRelation)
	op void visitJNIFunction(JNIFunction jniFunction)
	
	op void visitVariableDomain(VariableDomain vdom)
	op void visitRectangularDomain(RectangularDomain rdom)
	op void visitDefinedObject(DefinedObject dobj)
}

class AlphaRoot extends AlphaVisitable {
	contains AlphaElement[] elements
	
	op Imports[] getImports() { elements.filter(Imports).asEList }
	op AlphaConstant[] getConstants() { elements.filter(AlphaConstant).asEList }
	op ExternalFunction[] getExternalFunctions() { elements.filter(ExternalFunction).asEList }
	op AlphaPackage[] getPackages() { elements.filter(AlphaPackage).asEList }
	op AlphaSystem[] getSystems() { elements.filter(AlphaSystem).asEList }
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaRoot(this)
	}
}

abstract class AlphaElement extends AlphaVisitable {
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaElement(this)
	}
}

class Imports extends AlphaElement {
	String importedNamespace
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitImports(this)
	}
}

class AlphaPackage extends AlphaElement {
	 id String name
	 contains AlphaElement[] elements
	 
	op AlphaConstant[] getConstants() { elements.filter(AlphaConstant).asEList }
	op ExternalFunction[] getExternalFunctions() { elements.filter(ExternalFunction).asEList }
	op AlphaPackage[] getPackages() { elements.filter(AlphaPackage).asEList }
	op AlphaSystem[] getSystems() { elements.filter(AlphaSystem).asEList }
	 
	 op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaPackage(this)
	}
}

class AlphaConstant extends AlphaElement {
	String name
	int value 
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaConstant(this)
	}
}

class ExternalFunction extends AlphaElement {
	String name
	int cardinality
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitExternalFunction(this)
	}
}

class AlphaSystem extends AlphaElement {
	String name
	contains JNIDomain parameterDomain
	contains PolyhedralObject[] definedObjects
	contains InputVariable[] inputs
	contains OutputVariable[] outputs
	contains LocalVariable[] locals
	contains FuzzyVariable[] fuzzyVariables
	contains CalculatorExpression whileDomain
	contains AlphaExpression testExpression
	
	contains UseEquation[] useEquations
	contains StandardEquation[] equations
	
	op Variable[] getVariables() {
		(inputs+outputs+locals).asEList.unmodifiableEList
	}
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitAlphaSystem(this)
	}
}


class Variable extends AlphaVisitable {
	String name
	contains CalculatorExpression domainExpr
	
	op JNIISLSet getDomain() {
		if (domainExpr.^type != POLY_OBJECT_TYPE::SET) {
			return null
		}
		
		try {
			return domainExpr.ISLObject as JNIISLSet
		} catch (CyclicDefinitionException cde) {
			return null
		}
	}
	
	 op void accept(AlphaVisitor visitor) {
	 	visitor.visitVariable(this)
	}
}

class InputVariable extends Variable {
	op void accept(AlphaVisitor visitor) {
	 	visitor.visitInputVariable(this)
	}
}
class OutputVariable extends Variable {
	op void accept(AlphaVisitor visitor) {
	 	visitor.visitOutputVariable(this)
	}
}
class LocalVariable extends Variable {
	op void accept(AlphaVisitor visitor) {
	 	visitor.visitLocalVariable(this)
	}
}

class FuzzyVariable extends Variable {
	
	op JNIISLSet getDomain() {
		if (domainExpr.^type != POLY_OBJECT_TYPE::MAP) {
			return null
		}
		
		return (domainExpr.ISLObject as JNIISLMap).copy().domain()
	}
	
	op JNIISLMap getRelation() {
		if (domainExpr.^type != POLY_OBJECT_TYPE::MAP) {
			return null
		}
		
		return domainExpr.ISLObject as JNIISLMap
	}
	
	
	op void accept(AlphaVisitor visitor) {
	 	visitor.visitFuzzyVariable(this)
	}
}


class StandardEquation extends AlphaVisitable {
	refers Variable variable
	String[] indexNames
	contains AlphaExpression expr
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitStandardEquation(this)
	}
}
class UseEquation extends AlphaVisitable {
	refers AlphaSystem system
	contains CalculatorExpression instantiationDomain
	contains JNIFunctionInArrayNotation callParams
	String[] subsystemDims
	contains AlphaExpression[] inputExprs
	contains AlphaExpression[] outputExprs
	
	op void accept(AlphaVisitor visitor) {
		visitor.visitUseEquation(this)
	}
}

/** Alpha Expressions */

abstract class AlphaExpression extends AlphaExpressionVisitable {
	/*Internal object for always copying expression domain at getter */
	JNIISLSet z__internal_cache_exprDom
	/*Internal object for always copying context domain at getter */
	JNIISLSet z__internal_cache_contextDom
	String errorMessage
	
	op void setExpressionDomain(JNIISLSet dom) { this.setZ__internal_cache_exprDom(dom) }
	op JNIISLSet getExpressionDomain() { if (z__internal_cache_exprDom !== null) z__internal_cache_exprDom.copy else null }
	
	op void setContextDomain(JNIISLSet dom) { this.setZ__internal_cache_contextDom(dom) }
	op JNIISLSet getContextDomain() { if (z__internal_cache_contextDom !== null)  z__internal_cache_contextDom.copy else null }
}

class RestrictExpression extends AlphaExpression {
	contains CalculatorExpression domainExpr
	contains AlphaExpression expr
	
	op JNIISLSet getRestrictDomain() {
		if (domainExpr !== null && domainExpr.^type == POLY_OBJECT_TYPE.SET && domainExpr.ISLObject !== null) {
			return domainExpr.ISLObject as JNIISLSet
		}
		return null
	}
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitRestrictExpression(this)
	}
}
class AutoRestrictExpression extends AlphaExpression {
	contains AlphaExpression expr
	JNIISLSet z__internal_cache_inferredDomain
	
	op JNIISLSet getInferredDomain() { if (z__internal_cache_inferredDomain !== null) z__internal_cache_inferredDomain.copy else null }
	op void setInferredDomain(JNIISLSet islset) { z__internal_cache_inferredDomain = islset }
		
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAutoRestrictExpression(this)
	}
}

class CaseExpression extends AlphaExpression {
	String name
	contains AlphaExpression[] exprs
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitCaseExpression(this)
	}
}
class DependenceExpression extends AlphaExpression {
	contains JNIFunction function
	contains AlphaExpression expr
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitDependenceExpression(this)
	}
}
class IfExpression extends AlphaExpression {
	contains AlphaExpression condExpr
	contains AlphaExpression thenExpr
	contains AlphaExpression elseExpr
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitIfExpression(this)
	}
}
class IndexExpression extends AlphaExpression {
	contains JNIFunction function
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitIndexExpression(this)
	}
}
abstract class AbstractReduceExpression extends AlphaExpression {
	REDUCTION_OP operator
	contains JNIFunction projection
	contains AlphaExpression body
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitAbstractReduceExpression(this)
	}
}
class ReduceExpression extends AbstractReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitReduceExpression(this)
	}
}
class ExternalReduceExpression extends ReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitExternalReduceExpression(this)
	}
}
class ArgReduceExpression extends AbstractReduceExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitArgReduceExpression(this)
	}
}
class ExternalArgReduceExpression extends ArgReduceExpression {
	refers ExternalFunction externalFunction
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitExternalArgReduceExpression(this)
	}
}
class ConvolutionExpression extends AlphaExpression {
	contains CalculatorExpression kernelDomain
	contains AlphaExpression kernelExpression
	contains AlphaExpression dataExpression

	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitConvolutionExpression(this)
	}
}
class SelectExpression extends AlphaExpression {
	contains CalculatorExpression selectRelation
	contains AlphaExpression expr


	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitSelectExpression(this)
	}
}
class VariableExpression extends AlphaExpression {
	refers Variable variable
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitVariableExpression(this)
	}
}
abstract class ConstantExpression extends AlphaExpression {
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitConstantExpression(this)
	}
}
class IntegerExpression extends ConstantExpression {
	int value
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitIntegerExpression(this)
	}
}
class RealExpression extends ConstantExpression {
	float value
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitRealExpression(this)
	}
}
class BooleanExpression extends ConstantExpression {
	boolean value
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitBooleanExpression(this)
	}
}
class UnaryExpression extends AlphaExpression {
	UNARY_OP operator
	contains AlphaExpression expr
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitUnaryExpression(this)
	}
}
class BinaryExpression extends AlphaExpression {
	BINARY_OP operator
	contains AlphaExpression left
	contains AlphaExpression right
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitBinaryExpression(this)
	}
}
class MultiArgExpression extends AlphaExpression {
	REDUCTION_OP operator
	contains AlphaExpression[] exprs
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitMultiArgExpression(this)
	}
}
class ExternalMultiArgExpression extends MultiArgExpression {
	refers ExternalFunction externalFunction 
	
	op void accept(AlphaExpressionVisitor visitor) {
		visitor.visitExternalMultiArgExpression(this)
	}
}

enum UNARY_OP {
	NOT as "not"
	NEGATE as "-"
}

enum BINARY_OP {
	MIN as "min"
	MAX as "max"
	
	MUL as "*"
	DIV as "/"
	MOD as "%"
	
	ADD as "+"
	SUB as "-"
	
	AND as "and"
	OR  as "or"
	XOR as "xor"
	
	EQ as "="
	NE as "!="
	GE as ">="
	GT as ">"
	LE as "<="
	LT as "<"
}

enum REDUCTION_OP {
	MIN as "min"
	MAX as "max"
	PROD as "prod"
	SUM as "sum"
	AND as "and"
	OR as "or"
	XOR as "xor"
	
	EX as "external"
}


/** Calculator Expressions **/
enum POLY_OBJECT_TYPE {
	SET
	MAP
	FUNCTION
}

enum CALCULATOR_UNARY_OP {
	GET_DOMAIN as "domain"
	GET_RANGE as "range"
	COMPLEMENT as "complement"
	POLYHEDRAL_HULL as "poly-hull"
	AFFINE_HULL as "affine-hull"
	REVERSE as "reverse"
}

enum CALCULATOR_BINARY_OP {
	INTERSECT as "*"
	UNION as "+"
	CROSS_PRODUCT as "cross"
	SET_DIFFERENCE as "-"
	JOIN as "@"
	INTERSECT_RANGE as "->*"
	SUBTRACT_RANGE as "->-"
}

interface CalculatorNode {
	op POLY_OBJECT_TYPE getType()
	op JNIObject getISLObject()
}

class PolyhedralObject extends CalculatorNode, AlphaVisitable {
	String name
	contains CalculatorExpression expr
	
	op POLY_OBJECT_TYPE getType() { expr.^type }
	op JNIObject getISLObject() { 
		AlphaUtil.copy(expr.ISLObject)
	}
	
	
	op void accept(AlphaVisitor visitor) {
	 	visitor.visitPolyhedralObject(this)
	}
}

abstract class CalculatorExpression extends CalculatorNode, CalculatorExpressionVisitable {
//	String errorMessage
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitCalculatorExpression(this);
	}
}

class JNIDomain extends CalculatorExpression {
	String islString
	JNIISLSet z__internal_cache_islSet
	
	op JNIISLSet getISLSet() { if (z__internal_cache_islSet !== null) z__internal_cache_islSet.copy else null }
	op void setISLSet(JNIISLSet islset) { z__internal_cache_islSet = islset }
	
	op POLY_OBJECT_TYPE getType() { POLY_OBJECT_TYPE::SET }
	op JNIObject getISLObject() { getISLSet }
	
	op String toString() {
		if (z__internal_cache_islSet !== null) {
			return z__internal_cache_islSet.toString(ISL_FORMAT::ISL);
		} else {
			return "null ISL object"
		}
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitJNIDomain(this);
	}
}
class JNIDomainInArrayNotation extends JNIDomain {
	
}

class JNIRelation extends CalculatorExpression {
	String islString
	JNIISLMap z__internal_cache_islMap
	
	op JNIISLMap getISLMap() { if (z__internal_cache_islMap !== null) z__internal_cache_islMap.copy else null }
	op void setISLMap(JNIISLMap islMap) { z__internal_cache_islMap = islMap }
	
	op POLY_OBJECT_TYPE getType() { POLY_OBJECT_TYPE::MAP }
	op JNIObject getISLObject() { ISLMap }
	
	op String toString() {
		if (z__internal_cache_islMap !== null) {
			return z__internal_cache_islMap.toString(ISL_FORMAT::ISL);
		} else {
			return "null ISL object"
		}
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitJNIRelation(this);
	}
}

class JNIFunction extends CalculatorExpression {
	String alphaString
	JNIISLMultiAff z__internal_cache_islMAff
	
	op JNIISLMultiAff getISLMultiAff() { if (z__internal_cache_islMAff !== null) z__internal_cache_islMAff.copy else null }
	op void setISLMultiAff(JNIISLMultiAff islMAff) { z__internal_cache_islMAff = islMAff }
	
	op POLY_OBJECT_TYPE getType() { POLY_OBJECT_TYPE::FUNCTION }
	op JNIObject getISLObject() { ISLMultiAff }
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitJNIFunction(this);
	}
}

class JNIFunctionInArrayNotation extends JNIFunction {
	String[] arrayNotation
}

class UnaryCalculatorExpression extends CalculatorExpression {
	CALCULATOR_UNARY_OP operator
	contains CalculatorExpression expr
	
	JNIObject z__internal_cache_islObject
	
	op POLY_OBJECT_TYPE getType() { 
		if (z__internal_cache_islObject instanceof JNIISLSet)
			return POLY_OBJECT_TYPE::SET
		if (z__internal_cache_islObject instanceof JNIISLMap)
			return POLY_OBJECT_TYPE::MAP
		return null
	}
	op JNIObject getISLObject() { 
		AlphaUtil.copy(z__internal_cache_islObject)
	}
	
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitUnaryCalculatorExpression(this);
	}
}

class BinaryCalculatorExpression extends CalculatorExpression {
	CALCULATOR_BINARY_OP operator
	contains CalculatorExpression left
	contains CalculatorExpression right
	
	JNIObject z__internal_cache_islObject
	
	op POLY_OBJECT_TYPE getType() { 
		if (z__internal_cache_islObject instanceof JNIISLSet)
			return POLY_OBJECT_TYPE::SET
		if (z__internal_cache_islObject instanceof JNIISLMap)
			return POLY_OBJECT_TYPE::MAP
		return null
	}
	op JNIObject getISLObject() { 
		AlphaUtil.copy(z__internal_cache_islObject)
	}

	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitBinaryCalculatorExpression(this);
	}
}

/* VariableDomain refers to the domain of declared variables */
class VariableDomain extends CalculatorExpression {
	refers Variable variable
	
	op POLY_OBJECT_TYPE getType() { return POLY_OBJECT_TYPE::SET }
	op JNIObject getISLObject() { if (variable !== null) variable.domain else null }
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitVariableDomain(this);
	}
}

/* RectangularDomain is a short-hand for rectilinear domains bounded by 0 from below, and by some parameter from above.
 * The dimensionality of the domain is the length of upperBounds that give the upper bound for each dimension.
 * The index names can be optionally specified for each dimension. (It is not possible to only name a subset of the dimensions.)
 * 
 * The bounds are of the form: 0<=i<N; each dimension will have N integer points starting from 0. 
 */
class RectangularDomain extends CalculatorExpression {
	String[] upperBounds
	String[] indexNames
	
	JNIISLSet z__internal_cache_islSet
	
	op JNIISLSet getISLSet() { if (z__internal_cache_islSet !== null) z__internal_cache_islSet.copy else null}
	op void setISLSet(JNIISLSet islset) { z__internal_cache_islSet = islset }
	
	op POLY_OBJECT_TYPE getType() { return POLY_OBJECT_TYPE::SET }
	op JNIObject getISLObject() { ISLSet }
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitRectangularDomain(this);
	}
}

/* Reference to an already defined object in the calculator section */
class DefinedObject extends CalculatorExpression {
	refers PolyhedralObject object
	boolean z__internalCycleDetector
	
	op POLY_OBJECT_TYPE getType() { return object.getType }
	op JNIObject getISLObject() {
		
		if (object !== null) {
			if (z__internalCycleDetector) {
				throw new CyclicDefinitionException("Cycle detected in the definition of: " + object.name);
			}
			z__internalCycleDetector = true;
			val res = object.ISLObject
			z__internalCycleDetector = false
			return res
		}
		return null
	}
	
	op void accept(CalculatorExpressionVisitor visitor) {
		visitor.visitDefinedObject(this);
	}
}
