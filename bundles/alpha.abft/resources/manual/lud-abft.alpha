affine lud_abft [N]->{:N>0}
 inputs
	A   	 	 : {[i,j] : 0<=i,j<N}
 outputs
	L   	 	 : {[i,j] : 0<=i<N and 0<=j<=i}
	U		 	 : {[i,j] : 0<=j<N and 0<=i<=j}
	Inv_L_c		 : {[j]	  : 0<=j<N}
	Inv_U_r		 : {[i]	  : 0<=i<N}
 locals
	L_c_0, L_c_1 : {[j]   : 0<=j<N}
	U_r_0, U_r_1 : {[i]   : 0<=i<N}
// locals	
//	A_c 	 	 : {[j]   : 0<=j<N}
//	A_r 	 	 : {[i]   : 0<=i<N}
// locals
//	A_f 	 	 : {[i,j] : 0<=i,j<N}
	
 let
	U[i,j] = case {
		{: 0 = i}      : A[i,j];
		{: 0 < i <= j} : A[i,j] - reduce(+, [k], {: 0<=k<i} : L[i,k]*U[k,j]);
	};
	
	L[i,j] = case {
		{: 0 = j} : (A[i,j] / U[j,j]);
   		{: 0 < j} : (A[i,j] - reduce(+, [k], {: 0<=k<j} : L[i,k]*U[k,j])) / U[j,j];
	};
	
	L_c_0[j] = reduce(+, [i], L[i,j]);
	
	L_c_1[j] = reduce(+, [i], case{
		{: 0 = j} : (A[i,j] / U[j,j]);
   		{: 0 < j} : (A[i,j] - reduce(+, [k], {: 0<=k<j} : L[i,k]*U[k,j])) / U[j,j];
	});
		
	U_r_0[i] = reduce(+, [j], U[i,j]); 
		
	U_r_1[i] = reduce(+, [j], case{
		{: 0 = i}      : A[i,j];
		{: 0 < i <= j} : A[i,j] - reduce(+, [k], {: 0<=k<i} : L[i,k]*U[k,j]);
	});
	
	Inv_L_c[j] = (L_c_0 - L_c_1) / L_c_0;
	Inv_U_r[i] = (U_r_0 - U_r_1) / U_r_0;
	
//	A_c[j] = reduce(+, [i], A[i,j]);
//
//	A_r[i] = reduce(+, [j], A[i,j]);
//	
//	A_f[i,j] = reduce(+, [k], L[i,k]*U[k,j]);
//	case {
//		{: i = 0}   : U[i,j];
//		{: i > 0}	: L[i,j];
//		{: i > 0 and j     }   : 
//		
//	};
	
.