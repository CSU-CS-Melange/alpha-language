/*
 * generated by Xtext 2.18.0.M3
 */
package alpha.targetmapping.scoping

import alpha.model.Variable
import alpha.targetmapping.FilterExpression
import alpha.targetmapping.MemoryMapping
import alpha.targetmapping.ScheduleTargetRestrictDomain
import alpha.targetmapping.SpaceTimeMapping
import alpha.targetmapping.TargetMapping
import alpha.targetmapping.TargetmappingPackage
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import alpha.model.Equation
import alpha.model.AlphaScheduleTarget
import org.eclipse.xtext.naming.QualifiedName
import alpha.targetmapping.ExtensionTarget
import alpha.targetmapping.ScopingEntity
import alpha.targetmapping.ExtensionExpression

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class TargetMappingScopeProvider extends AbstractTargetMappingScopeProvider {

		override getScope(EObject context, EReference reference) {
			
			if ((context instanceof ScheduleTargetRestrictDomain && reference == TargetmappingPackage.Literals.SCHEDULE_TARGET_RESTRICT_DOMAIN__SCHEDULE_TARGET) ||
				(context instanceof ExtensionTarget && reference == TargetmappingPackage.Literals.EXTENSION_TARGET__SOURCE)
			) {
				
				//find the relevant scoping entity
				//  must skip FilterExpression/ExtensionExpression immediately surrounding the context
				val scopingEntity = 
					if (context.eContainer instanceof FilterExpression || context.eContainer instanceof ExtensionExpression) 
						EcoreUtil2.getContainerOfType(context.eContainer.eContainer, ScopingEntity)
					else
						EcoreUtil2.getContainerOfType(context, ScopingEntity)
				return constructScope(scopingEntity);
			}

			if ((context instanceof SpaceTimeMapping || context instanceof MemoryMapping) && reference == TargetmappingPackage.Literals.ABSTRACT_MAPPING__SCHEDULE_TARGET) {
				val tm = EcoreUtil2.getRootContainer(context) as TargetMapping
				val scope = EcoreUtil2.getAllContentsOfType(tm.targetSystem, Variable)
				return Scopes.scopeFor(scope.filter[eq|eq.name!==null], [eq|QualifiedName.create(eq.name)], IScope.NULLSCOPE)
			}		
			
			super.getScope(context, reference)
			
		}
		
		private def dispatch constructScope(TargetMapping tm) {
			val scope = EcoreUtil2.getAllContentsOfType(tm.targetSystem, AlphaScheduleTarget)
			return  Scopes.scopeFor(scope.filter[eq|eq.name!==null], [eq|QualifiedName.create(eq.name)], IScope.NULLSCOPE)
		}
		
		
		private def dispatch constructScope(FilterExpression fe) {
			val tm = EcoreUtil2.getRootContainer(fe) as TargetMapping
			val scope = EcoreUtil2.getAllContentsOfType(tm.targetSystem, AlphaScheduleTarget)
				
			val validTargets = fe.filterDomains.map[fd|fd.scheduleTarget.name]
			val filteredScope = scope.filter[t|validTargets.contains(t.name)]
			return Scopes.scopeFor(filteredScope.filter[eq|eq.name!==null], [eq|QualifiedName.create(eq.name)], IScope.NULLSCOPE)
		}

		private def dispatch constructScope(ExtensionExpression ee) {
			return Scopes.scopeFor(ee.extensionTargets.filter[et|et.name!==null], [et|QualifiedName.create(et.name)], IScope.NULLSCOPE)
		}
}
