/**
 * generated by Xtext 2.18.0.M3
 */
package alpha.targetmapping.scoping;

import alpha.model.AlphaScheduleTarget;
import alpha.model.SystemBody;
import alpha.targetmapping.ExtensionExpression;
import alpha.targetmapping.ExtensionTarget;
import alpha.targetmapping.FilterExpression;
import alpha.targetmapping.ScheduleTargetRestrictDomain;
import alpha.targetmapping.ScopingEntity;
import alpha.targetmapping.TargetMapping;
import alpha.targetmapping.TargetMappingForSystemBody;
import alpha.targetmapping.TargetMappingNode;
import alpha.targetmapping.TargetmappingPackage;
import com.google.common.base.Function;
import com.google.common.base.Objects;
import java.util.Arrays;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class TargetMappingScopeProvider extends AbstractTargetMappingScopeProvider {
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope _xblockexpression = null;
    {
      if (((context instanceof TargetMappingForSystemBody) && Objects.equal(reference, TargetmappingPackage.Literals.TARGET_MAPPING_FOR_SYSTEM_BODY__TARGET_BODY))) {
        EObject _eContainer = context.eContainer();
        final TargetMapping tm = ((TargetMapping) _eContainer);
        final EList<SystemBody> sbodies = tm.getTargetSystem().getSystemBodies();
        final Function<SystemBody, QualifiedName> _function = (SystemBody sb) -> {
          int _indexOf = sbodies.indexOf(sb);
          String _plus = (Integer.valueOf(_indexOf) + "");
          return QualifiedName.create(_plus);
        };
        return Scopes.<SystemBody>scopeFor(sbodies, _function, IScope.NULLSCOPE);
      }
      if (((context instanceof ScheduleTargetRestrictDomain) && Objects.equal(reference, TargetmappingPackage.Literals.SCHEDULE_TARGET_RESTRICT_DOMAIN__SCHEDULE_TARGET))) {
        ScopingEntity _xifexpression = null;
        if (((context.eContainer() instanceof FilterExpression) || (context.eContainer() instanceof ExtensionExpression))) {
          _xifexpression = EcoreUtil2.<ScopingEntity>getContainerOfType(context.eContainer().eContainer(), ScopingEntity.class);
        } else {
          _xifexpression = EcoreUtil2.<ScopingEntity>getContainerOfType(context, ScopingEntity.class);
        }
        final ScopingEntity scopingEntity = _xifexpression;
        return this.constructScope(scopingEntity);
      }
      _xblockexpression = super.getScope(context, reference);
    }
    return _xblockexpression;
  }

  private IScope _constructScope(final TargetMapping tm) {
    return this.scheduleTargetsToScope(this.findRootScope(tm));
  }

  private IScope _constructScope(final TargetMappingForSystemBody tm) {
    return this.scheduleTargetsToScope(this.findRootScope(tm));
  }

  private IScope _constructScope(final FilterExpression fe) {
    final List<AlphaScheduleTarget> scope = this.findRootScope(fe);
    final Function1<ScheduleTargetRestrictDomain, String> _function = (ScheduleTargetRestrictDomain fd) -> {
      return fd.getScheduleTarget().getName();
    };
    final List<String> validTargets = ListExtensions.<ScheduleTargetRestrictDomain, String>map(fe.getFilterDomains(), _function);
    final Function1<AlphaScheduleTarget, Boolean> _function_1 = (AlphaScheduleTarget t) -> {
      return Boolean.valueOf(validTargets.contains(t.getName()));
    };
    final Iterable<AlphaScheduleTarget> filteredScope = IterableExtensions.<AlphaScheduleTarget>filter(scope, _function_1);
    return this.scheduleTargetsToScope(filteredScope);
  }

  private IScope _constructScope(final ExtensionExpression ee) {
    EList<ExtensionTarget> _extensionTargets = ee.getExtensionTargets();
    return this.scheduleTargetsToScope(((Iterable<? extends AlphaScheduleTarget>) _extensionTargets));
  }

  private List<AlphaScheduleTarget> findRootScope(final TargetMappingNode tmn) {
    if ((tmn instanceof TargetMapping)) {
      return EcoreUtil2.<AlphaScheduleTarget>getAllContentsOfType(((TargetMapping)tmn).getTargetSystem(), AlphaScheduleTarget.class);
    }
    if ((tmn instanceof TargetMappingForSystemBody)) {
      SystemBody _targetBody = ((TargetMappingForSystemBody)tmn).getTargetBody();
      boolean _tripleNotEquals = (_targetBody != null);
      if (_tripleNotEquals) {
        return EcoreUtil2.<AlphaScheduleTarget>getAllContentsOfType(((TargetMappingForSystemBody)tmn).getTargetBody(), AlphaScheduleTarget.class);
      } else {
        EObject _eContainer = ((TargetMappingForSystemBody)tmn).eContainer();
        return this.findRootScope(((TargetMapping) _eContainer));
      }
    }
    EObject _eContainer_1 = tmn.eContainer();
    boolean _tripleEquals = (_eContainer_1 == null);
    if (_tripleEquals) {
      throw new RuntimeException("Uncontained TargetMappingNode.");
    }
    EObject _eContainer_2 = tmn.eContainer();
    return this.findRootScope(((TargetMappingNode) _eContainer_2));
  }

  private IScope scheduleTargetsToScope(final Iterable<? extends AlphaScheduleTarget> scope) {
    final Function1<AlphaScheduleTarget, Boolean> _function = (AlphaScheduleTarget eq) -> {
      String _name = eq.getName();
      return Boolean.valueOf((_name != null));
    };
    final Function<AlphaScheduleTarget, QualifiedName> _function_1 = (AlphaScheduleTarget eq) -> {
      return QualifiedName.create(eq.getName());
    };
    return Scopes.<AlphaScheduleTarget>scopeFor(IterableExtensions.filter(scope, _function), _function_1, IScope.NULLSCOPE);
  }

  private IScope constructScope(final EObject ee) {
    if (ee instanceof ExtensionExpression) {
      return _constructScope((ExtensionExpression)ee);
    } else if (ee instanceof FilterExpression) {
      return _constructScope((FilterExpression)ee);
    } else if (ee instanceof TargetMapping) {
      return _constructScope((TargetMapping)ee);
    } else if (ee instanceof TargetMappingForSystemBody) {
      return _constructScope((TargetMappingForSystemBody)ee);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(ee).toString());
    }
  }
}
