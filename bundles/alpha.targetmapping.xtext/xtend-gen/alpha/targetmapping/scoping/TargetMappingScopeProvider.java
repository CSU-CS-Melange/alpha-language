/**
 * generated by Xtext 2.18.0.M3
 */
package alpha.targetmapping.scoping;

import alpha.model.AlphaScheduleTarget;
import alpha.model.Variable;
import alpha.targetmapping.ExtensionExpression;
import alpha.targetmapping.ExtensionTarget;
import alpha.targetmapping.FilterExpression;
import alpha.targetmapping.MemoryMapping;
import alpha.targetmapping.ScheduleTargetRestrictDomain;
import alpha.targetmapping.ScopingEntity;
import alpha.targetmapping.SpaceTimeMapping;
import alpha.targetmapping.TargetMapping;
import alpha.targetmapping.TargetmappingPackage;
import alpha.targetmapping.scoping.AbstractTargetMappingScopeProvider;
import com.google.common.base.Function;
import com.google.common.base.Objects;
import java.util.Arrays;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class TargetMappingScopeProvider extends AbstractTargetMappingScopeProvider {
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope _xblockexpression = null;
    {
      if ((((context instanceof ScheduleTargetRestrictDomain) && Objects.equal(reference, TargetmappingPackage.Literals.SCHEDULE_TARGET_RESTRICT_DOMAIN__SCHEDULE_TARGET)) || ((context instanceof ExtensionTarget) && Objects.equal(reference, TargetmappingPackage.Literals.EXTENSION_TARGET__SOURCE)))) {
        ScopingEntity _xifexpression = null;
        if (((context.eContainer() instanceof FilterExpression) || (context.eContainer() instanceof ExtensionExpression))) {
          _xifexpression = EcoreUtil2.<ScopingEntity>getContainerOfType(context.eContainer().eContainer(), ScopingEntity.class);
        } else {
          _xifexpression = EcoreUtil2.<ScopingEntity>getContainerOfType(context, ScopingEntity.class);
        }
        final ScopingEntity scopingEntity = _xifexpression;
        return this.constructScope(scopingEntity);
      }
      if ((((context instanceof SpaceTimeMapping) || (context instanceof MemoryMapping)) && Objects.equal(reference, TargetmappingPackage.Literals.ABSTRACT_MAPPING__SCHEDULE_TARGET))) {
        EObject _rootContainer = EcoreUtil2.getRootContainer(context);
        final TargetMapping tm = ((TargetMapping) _rootContainer);
        final List<Variable> scope = EcoreUtil2.<Variable>getAllContentsOfType(tm.getTargetSystem(), Variable.class);
        final Function1<Variable, Boolean> _function = (Variable eq) -> {
          String _name = eq.getName();
          return Boolean.valueOf((_name != null));
        };
        final Function<Variable, QualifiedName> _function_1 = (Variable eq) -> {
          return QualifiedName.create(eq.getName());
        };
        return Scopes.<Variable>scopeFor(IterableExtensions.<Variable>filter(scope, _function), _function_1, IScope.NULLSCOPE);
      }
      _xblockexpression = super.getScope(context, reference);
    }
    return _xblockexpression;
  }
  
  private IScope _constructScope(final TargetMapping tm) {
    final List<AlphaScheduleTarget> scope = EcoreUtil2.<AlphaScheduleTarget>getAllContentsOfType(tm.getTargetSystem(), AlphaScheduleTarget.class);
    final Function1<AlphaScheduleTarget, Boolean> _function = (AlphaScheduleTarget eq) -> {
      String _name = eq.getName();
      return Boolean.valueOf((_name != null));
    };
    final Function<AlphaScheduleTarget, QualifiedName> _function_1 = (AlphaScheduleTarget eq) -> {
      return QualifiedName.create(eq.getName());
    };
    return Scopes.<AlphaScheduleTarget>scopeFor(IterableExtensions.<AlphaScheduleTarget>filter(scope, _function), _function_1, IScope.NULLSCOPE);
  }
  
  private IScope _constructScope(final FilterExpression fe) {
    EObject _rootContainer = EcoreUtil2.getRootContainer(fe);
    final TargetMapping tm = ((TargetMapping) _rootContainer);
    final List<AlphaScheduleTarget> scope = EcoreUtil2.<AlphaScheduleTarget>getAllContentsOfType(tm.getTargetSystem(), AlphaScheduleTarget.class);
    final Function1<ScheduleTargetRestrictDomain, String> _function = (ScheduleTargetRestrictDomain fd) -> {
      return fd.getScheduleTarget().getName();
    };
    final List<String> validTargets = ListExtensions.<ScheduleTargetRestrictDomain, String>map(fe.getFilterDomains(), _function);
    final Function1<AlphaScheduleTarget, Boolean> _function_1 = (AlphaScheduleTarget t) -> {
      return Boolean.valueOf(validTargets.contains(t.getName()));
    };
    final Iterable<AlphaScheduleTarget> filteredScope = IterableExtensions.<AlphaScheduleTarget>filter(scope, _function_1);
    final Function1<AlphaScheduleTarget, Boolean> _function_2 = (AlphaScheduleTarget eq) -> {
      String _name = eq.getName();
      return Boolean.valueOf((_name != null));
    };
    final Function<AlphaScheduleTarget, QualifiedName> _function_3 = (AlphaScheduleTarget eq) -> {
      return QualifiedName.create(eq.getName());
    };
    return Scopes.<AlphaScheduleTarget>scopeFor(IterableExtensions.<AlphaScheduleTarget>filter(filteredScope, _function_2), _function_3, IScope.NULLSCOPE);
  }
  
  private IScope _constructScope(final ExtensionExpression ee) {
    final Function1<ExtensionTarget, Boolean> _function = (ExtensionTarget et) -> {
      String _name = et.getName();
      return Boolean.valueOf((_name != null));
    };
    final Function<ExtensionTarget, QualifiedName> _function_1 = (ExtensionTarget et) -> {
      return QualifiedName.create(et.getName());
    };
    return Scopes.<ExtensionTarget>scopeFor(IterableExtensions.<ExtensionTarget>filter(ee.getExtensionTargets(), _function), _function_1, IScope.NULLSCOPE);
  }
  
  private IScope constructScope(final EObject ee) {
    if (ee instanceof ExtensionExpression) {
      return _constructScope((ExtensionExpression)ee);
    } else if (ee instanceof FilterExpression) {
      return _constructScope((FilterExpression)ee);
    } else if (ee instanceof TargetMapping) {
      return _constructScope((TargetMapping)ee);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(ee).toString());
    }
  }
}
