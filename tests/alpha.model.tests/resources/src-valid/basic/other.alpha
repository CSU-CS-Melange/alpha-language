/*
external sqrt(1)
external tmp(2)
external abs(1)


affine test [P,Q,R] -> { : }
	inputs
		A : {[i] : P>0}
	outputs
		B :
	fuzzy
	    test : { [t,i,j]->[t,i',j'] : i<=i'<=i+1 or j<=j'<=j+1}
	let
		B = sqrt(reduce(+, [i], A));	
.

affine jacobi [T,N] -> { : T>0 and N>0}
	inputs 
		A : {[i,j] : 0<=i<N and 0<=j<N}
	outputs
		B : {[i,j] : 0<=i<N and 0<=j<N}
	locals
		temp : {[t] : 0<=t<T} cross {A}
	let
		temp[t,i,j] = case {
			{ [t,i,j] : t=0 } : A[i,j];
			{ [t,i,j] : t>1 and 0<i<N-1 and 0<j<N-1 } : A[i,j] + A[i,j+1] + A[i,j-1] + A[i+1,j] + A[i-1,j];
			{ [t,i,j] : t>1 and 0<i<N-1 and 0<j<N-1 } :
			case a
			{
				{ [t,i,j] : t>1 and 0<i<N-1 and 0<j<N-1 } : A[i,j] + A[i,j+1] + A[i,j-1] + A[i+1,j] + A[i-1,j];
			};
		};
.
			
affine Stencil [N] -> {:2<= N}
    define
    	D_Init = { [i,j] : 0<=i<N and 0<=j<N}
    	R_stencil = { [i,j] -> [i',j'] : i-1<=i'<=i+1 && j-1<=j'<=j+1 }
    	D_body = {[t]:t>0} cross (D_Init - domain (R_stencil ->- D_Init))
	inputs
		EPSILON :
		Init : D_Init
	outputs
    	Y : {Init}
    over {[t]:0<=t} while (reduce(max, [i,j], abs(Y[i,j,t]-Y[i,j,t-1])<EPSILON))
   let
   Y[i,j] = case {
      {[x,y,z]:x=0} : Init[y,z];
//      { {[x]:0<=x<2}cross D_body } : 0.2*(Y[t,i-1,j] + Y[t-1,i,j-1] + Y[t-1,i,j] + Y[t-1,i,j+1] + Y[t,i+1,j]);
      auto: select { [t,i,j]->[tp,i,j] : t-1<=tp<=t } from Y[tp,i,j];
	};
.
		
*/